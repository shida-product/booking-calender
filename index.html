<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>予約カレンダーシステム</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.08);
            overflow: hidden;
        }

        /* ヘッダー */
        .header {
            background: linear-gradient(135deg, #1976d2 0%, #1565c0 100%);
            color: white;
            padding: 32px;
            text-align: center;
            position: relative;
        }

        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .header p {
            font-size: 14px;
            opacity: 0.9;
        }

        /* データリセットボタン(検証用) */
        .reset-btn {
            position: absolute;
            top: 16px;
            right: 16px;
            padding: 8px 12px;
            background: #ffffff;
            color: #1565c0;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 700;
            transition: all 0.2s ease;
        }

        .reset-btn:hover {
            background: #e3f2fd;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(255,255,255,0.25);
        }

        /* タブ切り替え */
        .tabs {
            display: flex;
            background: #fafafa;
            border-bottom: 1px solid #e0e0e0;
        }

        .tab {
            flex: 1;
            padding: 18px;
            text-align: center;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            background: #fafafa;
            transition: all 0.3s ease;
            position: relative;
            color: #757575;
        }

        .tab:hover {
            background: #f5f5f5;
            color: #424242;
        }

        .tab.active {
            background: white;
            color: #1976d2;
            border-bottom: 3px solid #1976d2;
        }

        .tab .badge {
            position: absolute;
            top: 8px;
            right: 16px;
            background: #f44336;
            color: white;
            border-radius: 10px;
            padding: 3px 8px;
            font-size: 11px;
            font-weight: 700;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* コンテンツエリア */
        .content {
            padding: 24px;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* 週ナビゲーション */
        .week-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding: 16px 20px;
            background: #f5f5f5;
            border-radius: 12px;
        }

        .week-nav button {
            padding: 10px 20px;
            background: white;
            color: #1976d2;
            border: 2px solid #1976d2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .week-nav button:hover {
            background: #1976d2;
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.2);
        }

        .week-nav .week-info {
            font-size: 18px;
            font-weight: 600;
            color: #424242;
        }

        /* メニュー選択 */
        .menu-selection {
            margin-bottom: 24px;
            padding: 20px;
            background: #f5f5f5;
            border-radius: 12px;
        }

        .menu-selection h3 {
            margin-bottom: 16px;
            color: #424242;
            font-size: 16px;
            font-weight: 600;
        }

        .menu-options {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .menu-option {
            flex: 1;
            min-width: 200px;
            padding: 20px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s ease;
        }

        .menu-option:hover {
            border-color: #1976d2;
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(25, 118, 210, 0.12);
        }

        .menu-option.selected {
            border-color: #1976d2;
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        }

        .menu-option .menu-name {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 6px;
            color: #212121;
        }

        .menu-option .menu-duration {
            font-size: 14px;
            color: #757575;
        }

        /* カレンダー */
        .calendar {
            overflow-x: auto;
            margin-top: 16px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .calendar-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
        }

        .calendar-table th {
            background: linear-gradient(180deg, #1976d2 0%, #1565c0 100%);
            color: white;
            padding: 14px 8px;
            font-weight: 600;
            font-size: 14px;
            position: sticky;
            top: 0;
            z-index: 10;
            border-right: 1px solid rgba(255,255,255,0.1);
        }

        .calendar-table th:last-child {
            border-right: none;
        }

        .calendar-table th.date-header {
            padding: 8px;
            /* 曜日関係なく統一された色 */
            background: #1976d2;
            color: white;
        }

        .date-header .day-name {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
        }

        .date-header .date-num {
            display: block;
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 6px;
        }

        .date-header .block-all-btn {
            background: rgba(255,255,255,0.9);
            border: 2px solid #212121;
            color: #212121;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-block;
            width: 100%;
            font-weight: 600;
        }

        .date-header .block-all-btn:hover {
            background: white;
            border-color: #424242;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .calendar-table td {
            border: 1px solid #f0f0f0;
            padding: 0;
            text-align: center;
            vertical-align: middle;
        }

        .time-label {
            background: #fafafa;
            font-weight: 600;
            color: #616161;
            font-size: 13px;
            position: sticky;
            left: 0;
            z-index: 5;
            border-right: 2px solid #e0e0e0;
            padding: 12px 8px;
        }

        /* タイムスロット */
        .time-slot {
            height: 48px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: 600;
            user-select: none;
            position: relative;
        }

        .time-slot.available {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            color: #2e7d32;
        }

        .time-slot.available:hover {
            background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%);
            transform: scale(1.02);
            box-shadow: inset 0 0 0 2px #4caf50;
        }

        .time-slot.blocked {
            background: #f5f5f5;
            color: #bdbdbd;
            cursor: not-allowed;
        }

        .time-slot.blocked.removable {
            cursor: pointer;
            position: relative;
        }

        .time-slot.blocked.removable:hover {
            background: #ffebee;
            color: #c62828;
        }

        .time-slot.blocked.removable:hover::after {
            content: '解除';
            position: absolute;
            font-size: 11px;
            bottom: 2px;
            right: 4px;
        }

        .time-slot.pending {
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%);
            color: #ef6c00;
            font-size: 13px;
            animation: pendingPulse 2s infinite;
        }

        .time-slot.pending:hover {
            background: linear-gradient(135deg, #ffe0b2 0%, #ffcc80 100%);
            transform: scale(1.02);
        }

        @keyframes pendingPulse {
            0%, 100% { box-shadow: inset 0 0 0 2px transparent; }
            50% { box-shadow: inset 0 0 0 2px #ff9800; }
        }

        .time-slot.confirmed {
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
            color: #1565c0;
            font-size: 13px;
        }

        .time-slot.confirmed:hover {
            cursor: pointer;
        }

        .time-slot.interval {
            background: linear-gradient(135deg, #e1bee7 0%, #ce93d8 100%);
            color: #6a1b9a;
            font-size: 11px;
            cursor: pointer;
            animation: intervalPulse 2s infinite;
        }

        .time-slot.interval:hover {
            background: linear-gradient(135deg, #ce93d8 0%, #ba68c8 100%);
            transform: scale(1.02);
        }

        @keyframes intervalPulse {
            0%, 100% { box-shadow: inset 0 0 0 2px transparent; }
            50% { box-shadow: inset 0 0 0 2px #9c27b0; }
        }

        .time-slot.rejected {
            background: linear-gradient(135deg, #ffebee 0%, #ffcdd2 100%);
            color: #c62828;
            font-size: 13px;
        }

        .time-slot.dragging {
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            box-shadow: inset 0 0 0 3px #fbc02d;
        }

        /* 予約間インターバル表示 */
        .interval-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 9px;
            padding: 1px 3px;
            border-radius: 3px;
            font-weight: 700;
            z-index: 10;
            pointer-events: none;
        }

        .interval-indicator.ok {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .interval-indicator.warning {
            background: #fff9c4;
            color: #f57c00;
        }

        .interval-indicator.error {
            background: #ffcdd2;
            color: #c62828;
        }

        /* 利用者画面 - 15分グリッド */
        .hp-calendar { border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.06); }
        .hp-table { width: 100%; border-collapse: collapse; background: #fff; }
        .hp-table thead th { 
            position: sticky; 
            top: 0; 
            z-index: 10; 
            background: #1976d2; 
            border-bottom: 1px solid #1565c0; 
            font-size: 13px; 
            padding: 10px 0; 
            color: white; 
        }
        
        .hp-table th, .hp-table td { border-right: 1px solid #f0f0f0; }
        .hp-table th:last-child, .hp-table td:last-child { border-right: none; }
        .hp-time { background: #fafafa; position: sticky; left: 0; z-index: 5; font-size: 13px; color: #616161; padding: 10px 8px; border-right: 1px solid #e0e0e0; }
        .hp-slot { height: 48px; text-align: center; vertical-align: middle; padding: 0; }
        .hp-cell { width: 100%; height: 48px; display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: 600; border-radius: 0; }
        .hp-cell.available { background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); color: #2e7d32; cursor: pointer; }
        .hp-cell.available:hover { background: linear-gradient(135deg, #c8e6c9 0%, #a5d6a7 100%); box-shadow: inset 0 0 0 2px #4caf50; transform: scale(1.02); }
        .hp-cell.blocked { background: #f5f5f5; color: #bdbdbd; }

        /* モーダル */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
            animation: fadeIn 0.2s ease;
        }

        .modal-content {
            background: white;
            padding: 28px;
            border-radius: 16px;
            max-width: 520px;
            width: 90%;
            box-shadow: 0 12px 48px rgba(0,0,0,0.2);
            animation: slideUp 0.3s ease;
            max-height: 90vh;
            overflow-y: auto;
        }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: #212121;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 12px;
        }

        .modal-body {
            margin-bottom: 24px;
        }

        .modal-body .info-row {
            display: flex;
            justify-content: space-between;
            padding: 12px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .modal-body .info-label {
            font-weight: 600;
            color: #757575;
            font-size: 14px;
        }

        .modal-body .info-value {
            color: #212121;
            font-weight: 500;
            font-size: 14px;
        }

        .modal-body .sub-info { 
            display: inline-block; 
            margin-top: 4px; 
            color: #757575; 
            font-size: 12px; 
        }

        .modal-body textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            margin-top: 8px;
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
            transition: border-color 0.2s ease;
        }

        .modal-body textarea:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .modal-body label {
            display: block;
            margin-bottom: 8px;
            margin-top: 16px;
            font-weight: 600;
            color: #424242;
            font-size: 14px;
        }

        .modal-body select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            cursor: pointer;
            transition: border-color 0.2s ease;
        }

        .modal-body select:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .modal-footer {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }

        .modal-footer button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .btn-primary {
            background: #1976d2;
            color: white;
        }

        .btn-primary:hover {
            background: #1565c0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.3);
        }

        .btn-success {
            background: #4caf50;
            color: white;
        }

        .btn-success:hover {
            background: #43a047;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(76, 175, 80, 0.3);
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-danger:hover {
            background: #e53935;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
        }

        .btn-secondary {
            background: white;
            color: #757575;
            border: 2px solid #e0e0e0;
        }

        .btn-secondary:hover {
            background: #fafafa;
            border-color: #bdbdbd;
        }

        /* 説明テキスト */
        .instructions {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 16px 20px;
            border-radius: 12px;
            margin-bottom: 24px;
            border-left: 4px solid #1976d2;
        }

        .instructions h4 {
            margin-bottom: 12px;
            color: #1565c0;
            font-size: 15px;
            font-weight: 600;
        }

        .instructions ul {
            margin-left: 20px;
        }

        .instructions li {
            margin: 6px 0;
            color: #424242;
            font-size: 13px;
            line-height: 1.6;
        }

        /* 共通フォームスタイル */
        .form-select { 
            width: 100%; 
            padding: 12px; 
            border: 2px solid #e0e0e0; 
            border-radius: 8px; 
            font-size: 14px; 
            font-family: inherit; 
            cursor: pointer; 
            transition: border-color 0.2s ease; 
            background: #fff; 
        }
        .form-select:focus { 
            outline: none; 
            border-color: #1976d2; 
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1); 
        }
        .inline-controls { 
            display: flex; 
            gap: 12px; 
            align-items: center; 
            flex-wrap: wrap;
        }
        .inline-controls .status { 
            color: #424242; 
            font-size: 14px; 
        }

        /* 凡例 */
        .legend { 
            display: flex; 
            gap: 10px; 
            flex-wrap: wrap; 
            margin-top: 10px; 
            color: #616161; 
            font-size: 12px; 
        }
        .legend .item { 
            display: inline-flex; 
            align-items: center; 
            gap: 6px; 
            background: #fafafa; 
            border: 1px solid #e0e0e0; 
            border-radius: 16px; 
            padding: 4px 10px; 
        }
        .legend .chip { 
            width: 14px; 
            height: 14px; 
            border-radius: 3px; 
            box-shadow: inset 0 0 0 2px rgba(0,0,0,0.04); 
        }
        .chip-ok { 
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); 
            border: 1px solid #a5d6a7; 
        }
        .chip-pending { 
            background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); 
            border: 1px solid #ffcc80; 
        }
        .chip-confirmed { 
            background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); 
            border: 1px solid #90caf9; 
        }
        .chip-block { 
            background: #f5f5f5; 
            border: 1px solid #e0e0e0; 
        }

        /* 2列レイアウト（施術者画面のブロック時間設定） */
        .two-column-settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .setting-box {
            padding: 16px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
        }

        .setting-box h4 {
            margin-bottom: 12px;
            color: #424242;
            font-size: 14px;
            font-weight: 600;
        }

        /* モバイル対応 */
        @media (max-width: 768px) {
            body {
                padding: 0;
            }

            .container {
                border-radius: 0;
            }

            .header h1 {
                font-size: 22px;
            }

            .week-nav { 
                display: grid; 
                grid-template-columns: 1fr auto 1fr; 
                grid-template-areas: "date date date" "prev . next"; 
                row-gap: 8px; 
                align-items: center; 
                padding: 12px 14px; 
            }
            .week-nav .week-info { 
                grid-area: date; 
                text-align: center; 
                font-size: 14px; 
            }
            .week-nav button { 
                font-size: 12px; 
                padding: 8px 12px; 
            }
            #prevWeekProvider, #prevWeekCustomer { 
                grid-area: prev; 
                justify-self: start; 
            }
            #nextWeekProvider, #nextWeekCustomer { 
                grid-area: next; 
                justify-self: end; 
            }
            #openQuickBlockSheet { 
                grid-column: 1 / -1; 
                justify-self: stretch; 
            }

            .menu-options {
                flex-direction: column;
            }

            .calendar {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .calendar-table th {
                padding: 10px 4px;
                font-size: 12px;
            }
            .calendar-table th.date-header { 
                padding: 6px 4px;
                /* 曜日関係なく統一された色 */
                background: #1976d2;
                color: white;
            }
            .date-header .day-name { 
                font-size: 12px; 
            }
            .date-header .date-num { 
                font-size: 11px; 
            }
            .time-label {
                padding: 10px 6px;
                font-size: 12px;
            }

            .instructions { 
                padding: 12px 14px; 
                margin-bottom: 16px; 
            }
            .instructions h4 { 
                font-size: 14px; 
                margin-bottom: 8px; 
            }
            .instructions li { 
                font-size: 12px; 
                line-height: 1.5; 
            }

            .hp-calendar { 
                border-radius: 0; 
                box-shadow: none; 
            }
            .hp-table thead th { 
                position: sticky; 
                top: 0; 
                z-index: 10; 
                /* 曜日関係なく統一された色 */
                background: #1976d2;
                color: white;
                border-bottom: 1px solid #1565c0; 
                font-size: 12px; 
                padding: 6px 0; 
            }
            .hp-time { 
                background: #fafafa; 
                position: sticky; 
                left: 0; 
                z-index: 5; 
                font-size: 12px; 
                color: #616161; 
                padding: 8px 6px; 
                border-right: 1px solid #e0e0e0; 
            }
            .hp-slot { 
                height: 48px; 
            }

            .two-column-settings {
                grid-template-columns: 1fr;
            }

            .shift-dashboard {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "summary"
                    "actions";
                gap: 16px;
            }

            .shift-summary {
                grid-area: summary;
                order: 1;
            }

            .quick-actions {
                grid-area: actions;
                order: 2;
            }

            .shift-summary h3 {
                font-size: 14px;
                margin-bottom: 12px;
            }

            .summary-item {
                padding: 6px 0;
                font-size: 13px;
            }

            .summary-label,
            .summary-value {
                font-size: 13px;
            }

            .quick-actions h3 {
                font-size: 14px;
                margin-bottom: 12px;
            }

            .quick-actions button {
                padding: 10px;
                font-size: 13px;
                margin-bottom: 8px;
            }

            .shift-grid {
                gap: 4px;
                grid-template-columns: repeat(7, minmax(80px, 1fr));
                width: 100%;
            }

            .shift-day-header {
                padding: 8px 4px;
                font-size: 12px;
                position: sticky;
                top: 0;
                /* 曜日関係なく統一された色 */
                background: #1976d2;
                color: white;
                z-index: 1;
                border-bottom: 1px solid #1565c0;
            }

            .shift-day {
                padding: 6px 4px;
                min-height: 70px;
                aspect-ratio: auto;
            }

            .shift-date-num {
                font-size: 14px;
                margin-bottom: 2px;
            }

            .shift-time {
                font-size: 9px;
                line-height: 1.3;
                margin-top: 4px;
                word-break: break-word;
            }

            .shift-status {
                font-size: 10px;
                margin-top: 4px;
            }

            .shift-calendar {
                padding: 12px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .shift-calendar .shift-grid {
                min-width: 560px; /* 7列 x 80px = 560px minimum */
            }

            .month-nav {
                flex-direction: column;
                gap: 12px;
            }

            .month-nav button {
                width: 100%;
                padding: 10px;
            }

            .month-info {
                font-size: 16px;
                text-align: center;
            }
        }

        /* シフト管理画面 */
        .shift-dashboard {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 24px;
            margin-bottom: 24px;
        }

        .quick-actions {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 12px;
        }

        .quick-actions h3 {
            margin-bottom: 16px;
            color: #424242;
            font-size: 16px;
            font-weight: 600;
        }

        .quick-actions button {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            background: white;
            color: #1976d2;
            border: 2px solid #1976d2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .quick-actions button:hover {
            background: #1976d2;
            color: white;
        }

        .shift-summary {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            padding: 20px;
            border-radius: 12px;
            border-left: 4px solid #1976d2;
        }

        .shift-summary h3 {
            margin-bottom: 16px;
            color: #1565c0;
            font-size: 16px;
            font-weight: 600;
        }

        .summary-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid rgba(0,0,0,0.05);
        }

        .summary-item:last-child {
            border-bottom: none;
        }

        .summary-label {
            color: #616161;
            font-size: 14px;
        }

        .summary-value {
            font-weight: 600;
            color: #212121;
            font-size: 14px;
        }

        .summary-value.warning {
            color: #f57c00;
        }

        /* シフトカレンダー */
        .shift-calendar {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.06);
        }

        .month-nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .month-nav button {
            padding: 8px 16px;
            background: white;
            color: #1976d2;
            border: 2px solid #1976d2;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .month-nav button:hover {
            background: #1976d2;
            color: white;
        }

        .month-info {
            font-size: 20px;
            font-weight: 600;
            color: #424242;
        }

        .shift-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 8px;
            min-width: 100%;
        }

        .shift-day-header {
            text-align: center;
            padding: 8px;
            font-weight: 600;
            color: white;
            font-size: 13px;
            /* 曜日関係なく統一された色 */
            background: #1976d2;
        }

        .shift-day {
            aspect-ratio: 1;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .shift-day:hover {
            border-color: #1976d2;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.12);
        }

        .shift-day.other-month {
            opacity: 0.3;
            cursor: default;
        }

        .shift-day.other-month:hover {
            border-color: #e0e0e0;
            transform: none;
            box-shadow: none;
        }

        .shift-day.has-shift {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border-color: #4caf50;
        }

        .shift-day.no-shift {
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            border-color: #fbc02d;
        }

        .shift-day.off-day {
            background: #f5f5f5;
            border-color: #e0e0e0;
        }

        .shift-date-num {
            font-weight: 600;
            color: #212121;
            font-size: 16px;
        }

        .shift-time {
            font-size: 11px;
            color: #616161;
            text-align: center;
            margin-top: 4px;
        }

        .shift-status {
            font-size: 10px;
            text-align: center;
            margin-top: 4px;
            font-weight: 600;
        }

        .shift-status.working {
            color: #2e7d32;
        }

        .shift-status.off {
            color: #757575;
        }

        .shift-status.warning {
            color: #f57c00;
        }

        /* パターン管理 */
        .pattern-list {
            display: grid;
            gap: 16px;
        }

        .pattern-card {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 12px;
            padding: 20px;
            transition: all 0.2s ease;
        }

        .pattern-card:hover {
            border-color: #1976d2;
            box-shadow: 0 4px 12px rgba(25, 118, 210, 0.12);
        }

        .pattern-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .pattern-name {
            font-size: 18px;
            font-weight: 600;
            color: #212121;
        }

        .pattern-actions {
            display: flex;
            gap: 8px;
        }

        .pattern-actions button {
            padding: 6px 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .pattern-actions button:hover {
            border-color: #1976d2;
            color: #1976d2;
        }

        .pattern-schedule {
            font-size: 13px;
            color: #616161;
            line-height: 1.6;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #424242;
            font-size: 14px;
        }

        .form-group input[type="date"],
        .form-group input[type="text"],
        .form-group input[type="checkbox"],
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s ease;
        }

        .form-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #1976d2;
            box-shadow: 0 0 0 3px rgba(25, 118, 210, 0.1);
        }

        .time-range {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .time-range select {
            flex: 1;
        }

        .weekday-selector {
            display: flex;
            gap: 8px;
            flex-wrap: nowrap;
        }

        .weekday-checkbox {
            flex: 1;
            min-width: 0;
        }

        .weekday-checkbox input {
            display: none;
        }

        .weekday-checkbox label {
            display: block;
            padding: 10px;
            text-align: center;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
            color: #616161;
        }

        .weekday-checkbox input:checked + label {
            background: #1976d2;
            color: white;
            border-color: #1976d2;
        }

        .pattern-schedule-editor {
            display: grid;
            gap: 12px;
        }

        .schedule-row {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 12px;
            align-items: center;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            background: #fafafa;
            transition: all 0.2s ease;
        }

        .schedule-row:hover {
            border-color: #1976d2;
            background: #fff;
            box-shadow: 0 2px 8px rgba(25, 118, 210, 0.1);
        }

        .schedule-row:last-child {
            margin-bottom: 0;
        }

        .schedule-row .weekday-label {
            font-weight: 600;
            color: #1976d2;
            font-size: 15px;
            padding: 4px 8px;
            border-radius: 4px;
            background: rgba(25, 118, 210, 0.1);
            display: inline-block;
            width: fit-content;
        }

        .schedule-row .time-controls {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 8px;
            width: 100%;
        }

        .schedule-row input[type="checkbox"] {
            margin-right: 8px;
        }

        .time-slot.blocked.auto {
            background: #fafafa;
            color: #e0e0e0;
            font-size: 14px;
        }

        .time-slot.blocked.no-shift {
            background: linear-gradient(135deg, #fff9c4 0%, #fff59d 100%);
            color: #f57c00;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>📅 予約カレンダーシステム</h1>
            <p>施術者と利用者のマッチングシステム (インターバル型ブロック機能搭載)</p>
            <button class="reset-btn" onclick="resetData()" title="保存データを全て消去して初期状態に戻します">データリセット</button>
        </div>

        <!-- タブ -->
        <div class="tabs">
            <div class="tab" data-tab="shift">
                📅 シフト管理
            </div>
            <div class="tab active" data-tab="provider">
                施術者画面
                <span class="badge" id="pendingBadge" style="display: none;">0</span>
            </div>
            <div class="tab" data-tab="customer">
                利用者画面
            </div>
        </div>

        <!-- コンテンツ -->
        <div class="content">
            <!-- シフト管理画面 -->
            <div class="tab-content" id="shift-content">
                <div class="instructions">
                    <h4>📌 シフト管理機能について</h4>
                    <ul>
                        <li>シフトを登録すると、勤務時間外が自動的にブロックされます</li>
                        <li>個別登録・一括登録・パターン適用の3つの方法で設定可能です</li>
                        <li>シフト未登録日は⚠️警告マークで表示されます</li>
                        <li>稼働パターンを保存すると、繰り返しの設定が簡単になります</li>
                    </ul>
                </div>

                <div class="shift-dashboard">
                    <div class="quick-actions">
                        <h3>クイック操作</h3>
                        <button onclick="openShiftModal()">📝 個別シフト登録</button>
                        <button onclick="openBulkShiftModal()">📋 一括シフト登録</button>
                        <button onclick="openPatternApplyModal()">🔄 パターン適用</button>
                        <button onclick="openPatternManageModal()">⚙️ パターン管理</button>
                    </div>

                    <div class="shift-summary">
                        <h3>今月のシフト概要</h3>
                        <div class="summary-item">
                            <span class="summary-label">登録済</span>
                            <span class="summary-value" id="summaryRegistered">0日</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">未登録</span>
                            <span class="summary-value warning" id="summaryUnregistered">0日</span>
                        </div>
                        <div class="summary-item">
                            <span class="summary-label">休日</span>
                            <span class="summary-value" id="summaryOff">0日</span>
                        </div>
                    </div>
                </div>

                <div class="shift-calendar">
                    <div class="month-nav">
                        <button onclick="changeMonth(-1)">← 前月</button>
                        <div class="month-info" id="monthInfo"></div>
                        <button onclick="changeMonth(1)">次月 →</button>
                    </div>
                    <div class="shift-grid" id="shiftGrid"></div>
                </div>
            </div>

            <!-- 施術者画面 -->
            <div class="tab-content active" id="provider-content">
                <div class="instructions">
                    <h4>📌 使い方</h4>
                    <ul>
                        <li>「受付可能」の時間枠をドラッグ&ドロップでブロックを設定できます</li>
                        <li>「×」をクリックするとその枠のブロックを解除できます</li>
                        <li>日付下の「終日ブロック」ボタンで一日全体を一括ブロックできます</li>
                        <li>オレンジの「承認待ち」をクリックすると承認/不承認を選択できます</li>
                        <li>承認後は、予約時間帯が「予約済」として表示されます(予約済みをタップで顧客情報を表示)</li>
                        <li><strong>🆕 インターバル型ブロック:</strong> 各予約間のインターバルが設定時間以上確保されていればOK</li>
                        <li><strong>🆕 訪問施術・店舗施術:</strong> それぞれ個別にインターバル時間を設定できます</li>
                        <li><strong>🆕 予約間インターバル表示:</strong> 予約セルの右下に「前○分/後○分」と実際のインターバルが表示されます</li>
                    </ul>
                </div>
                
                <!-- インターバル時間設定 -->
                <div class="menu-selection" id="intervalSettingPanel">
                    <h3>予約間インターバル時間設定</h3>
                    <div class="two-column-settings">
                        <div class="setting-box">
                            <h4>🚗 訪問施術</h4>
                            <div class="inline-controls">
                                <select id="intervalVisitSelect" class="form-select" style="max-width:180px;">
                                    <option value="0">0分(インターバルなし)</option>
                                    <option value="15">15分</option>
                                    <option value="30" selected>30分</option>
                                    <option value="45">45分</option>
                                    <option value="60">60分</option>
                                    <option value="75">75分</option>
                                    <option value="90">90分</option>
                                    <option value="105">105分</option>
                                    <option value="120">120分</option>
                                </select>
                                <button class="btn-secondary" id="applyIntervalVisitBtn">適用</button>
                            </div>
                            <div class="status" style="margin-top:8px;">適用中: <span id="appliedIntervalVisitText">30</span>分</div>
                        </div>
                        
                        <div class="setting-box">
                            <h4>🏠 店舗施術</h4>
                            <div class="inline-controls">
                                <select id="intervalStoreSelect" class="form-select" style="max-width:180px;">
                                    <option value="0" selected>0分(インターバルなし)</option>
                                    <option value="15">15分</option>
                                    <option value="30">30分</option>
                                </select>
                                <button class="btn-secondary" id="applyIntervalStoreBtn">適用</button>
                            </div>
                            <div class="status" style="margin-top:8px;">適用中: <span id="appliedIntervalStoreText">0</span>分</div>
                        </div>
                    </div>
                </div>

                <div class="week-nav">
                    <button id="prevWeekProvider">← 前週</button>
                    <div class="week-info" id="weekInfoProvider"></div>
                    <button id="nextWeekProvider">次週 →</button>
                    <button id="openQuickBlockSheet" class="btn-primary" style="margin-left:12px;">+ ブロック</button>
                </div>

                <div class="calendar">
                    <table class="calendar-table" id="providerCalendar"></table>
                </div>
                <div class="legend" aria-hidden="false">
                    <span class="item"><span class="chip chip-ok"></span>受付可能</span>
                    <span class="item"><span class="chip chip-pending"></span>承認待ち(施術)</span>
                    <span class="item"><span class="chip chip-confirmed"></span>予約済み(施術)</span>
                    <span class="item"><span class="chip chip-block"></span>ブロック(手動)</span>
                </div>
            </div>

            <!-- 利用者画面 -->
            <div class="tab-content" id="customer-content">
                <div class="instructions">
                    <h4>📌 使い方</h4>
                    <ul>
                        <li><strong>🆕 施術タイプを選択:</strong> まず「訪問施術」または「店舗施術」を選択してください</li>
                        <li>次に施術メニューを選択してください</li>
                        <li>15分刻みのグリッドで空き状況を確認できます(◯:空き、×:満席)</li>
                        <li>◯の枠をタップして予約リクエストを送信できます</li>
                        <li>送信後はその時間帯が×(仮押さえ)となり、施術者の承認後に確定します</li>
                    </ul>
                </div>

                <!-- 施術タイプ選択 -->
                <div class="menu-selection">
                    <h3>施術タイプを選択</h3>
                    <div class="menu-options">
                        <div class="menu-option" data-type="visit">
                            <div class="menu-name">🚗 訪問施術</div>
                            <div class="menu-duration">出張サービス</div>
                        </div>
                        <div class="menu-option" data-type="store">
                            <div class="menu-name">🏠 店舗施術</div>
                            <div class="menu-duration">店舗でのサービス</div>
                        </div>
                    </div>
                </div>

                <!-- メニュー選択 -->
                <div class="menu-selection">
                    <h3>施術メニューを選択</h3>
                    <div class="menu-options">
                        <div class="menu-option" data-menu="1">
                            <div class="menu-name">施術①</div>
                            <div class="menu-duration">45分</div>
                        </div>
                        <div class="menu-option" data-menu="2">
                            <div class="menu-name">施術②</div>
                            <div class="menu-duration">60分</div>
                        </div>
                    </div>
                </div>

                <div class="week-nav">
                    <button id="prevWeekCustomer">← 前週</button>
                    <div class="week-info" id="weekInfoCustomer"></div>
                    <button id="nextWeekCustomer">次週 →</button>
                </div>

                <div class="calendar">
                    <table class="calendar-table" id="customerCalendar"></table>
                </div>
            </div>
        </div>
    </div>

    <!-- ブロック設定モーダル -->
    <div class="modal" id="blockModal" role="dialog" aria-modal="true" aria-labelledby="blockModalTitle">
        <div class="modal-content" tabindex="-1">
            <div class="modal-header" id="blockModalTitle">ブロック時間を設定</div>
            <div class="modal-body">
                <div class="info-row">
                    <span class="info-label">日時:</span>
                    <span class="info-value" id="blockDateTime"></span>
                </div>
                <label>ブロック時間:</label>
                <select id="blockDuration">
                    <option value="15">15分</option>
                    <option value="30">30分</option>
                    <option value="45">45分</option>
                    <option value="60">60分</option>
                    <option value="75">75分</option>
                    <option value="90">90分</option>
                    <option value="105">105分</option>
                    <option value="120">120分</option>
                </select>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeBlockModal()">キャンセル</button>
                <button class="btn-primary" onclick="confirmBlock()">ブロック設定</button>
            </div>
        </div>
    </div>

    <!-- 予約確認モーダル -->
    <div class="modal" id="bookingModal" role="dialog" aria-modal="true" aria-labelledby="bookingModalTitle">
        <div class="modal-content" tabindex="-1">
            <div class="modal-header" id="bookingModalTitle">予約内容確認</div>
            <div class="modal-body">
                <div class="info-row">
                    <span class="info-label">施術タイプ:</span>
                    <span class="info-value" id="bookingType"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">施術:</span>
                    <span class="info-value" id="bookingMenu"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">日時:</span>
                    <span class="info-value" id="bookingDateTime"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">所要時間:</span>
                    <span class="info-value" id="bookingDuration"></span>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeBookingModal()">キャンセル</button>
                <button class="btn-primary" onclick="confirmBooking()">予約リクエスト送信</button>
            </div>
        </div>
    </div>

    <!-- 承認/不承認モーダル -->
    <div class="modal" id="approvalModal" role="dialog" aria-modal="true" aria-labelledby="approvalModalTitle">
        <div class="modal-content" tabindex="-1">
            <div class="modal-header" id="approvalModalTitle">予約の承認/不承認</div>
            <div class="modal-body">
                <div class="info-row">
                    <span class="info-label">施術タイプ:</span>
                    <span class="info-value" id="approvalType"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">施術:</span>
                    <span class="info-value" id="approvalMenu"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">日時:</span>
                    <span class="info-value" id="approvalDateTime"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">予約時間:</span>
                    <span class="info-value" id="approvalCoreTime"></span>
                </div>
                
                <label>インターバル時間を変更:</label>
                <div style="margin-bottom:12px;">
                    <label style="font-size:13px;font-weight:500;color:#616161;margin-bottom:6px;display:block;">前のインターバル時間:</label>
                    <select id="approvalIntervalBefore" class="form-select" style="margin-bottom:12px;">
                        <!-- 選択肢は施術タイプに応じて動的に生成 -->
                    </select>
                    <label style="font-size:13px;font-weight:500;color:#616161;margin-bottom:6px;display:block;">後のインターバル時間:</label>
                    <select id="approvalIntervalAfter" class="form-select">
                        <!-- 選択肢は施術タイプに応じて動的に生成 -->
                    </select>
                </div>
                <div class="sub-info" style="margin-top:4px;">※承認後もインターバルを変更・解除できます</div>
                
                <label>コメント:</label>
                <textarea id="approvalComment" placeholder="利用者へのメッセージを入力してください&#10;例:移動時間の都合上、予約受付ができません&#10;〇月〇日 〇〇:〇〇〜〇〇:〇〇であれば受付可能です。"></textarea>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeApprovalModal()">キャンセル</button>
                <button class="btn-danger" onclick="rejectBooking()">不承認</button>
                <button class="btn-success" onclick="approveBooking()">承認</button>
            </div>
        </div>
    </div>

    <!-- 顧客情報モーダル(予約済みセル用) -->
    <div class="modal" id="customerInfoModal" role="dialog" aria-modal="true" aria-labelledby="customerInfoTitle">
        <div class="modal-content" tabindex="-1">
            <div class="modal-header" id="customerInfoTitle">顧客情報・予約詳細</div>
            <div class="modal-body">
                <div class="info-row">
                    <span class="info-label">お名前:</span>
                    <span class="info-value" id="ciName"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">連絡先:</span>
                    <span class="info-value" id="ciContact"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">施術タイプ:</span>
                    <span class="info-value" id="ciType"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">施術:</span>
                    <span class="info-value" id="ciMenu"></span>
                </div>
                <div class="info-row">
                    <span class="info-label">日時:</span>
                    <span class="info-value" id="ciDateTime"></span>
                </div>
                
                <label>インターバル時間を変更:</label>
                <div style="margin-bottom:12px;">
                    <label style="font-size:13px;font-weight:500;color:#616161;margin-bottom:6px;display:block;">前のインターバル時間:</label>
                    <select id="ciIntervalBefore" class="form-select" style="margin-bottom:12px;">
                        <!-- 選択肢は施術タイプに応じて動的に生成 -->
                    </select>
                    <label style="font-size:13px;font-weight:500;color:#616161;margin-bottom:6px;display:block;">後のインターバル時間:</label>
                    <select id="ciIntervalAfter" class="form-select">
                        <!-- 選択肢は施術タイプに応じて動的に生成 -->
                    </select>
                </div>
                <button class="btn-primary" onclick="updateBookingInterval()" style="margin-top:12px;width:100%;">インターバル時間を更新</button>
            </div>
            <div class="modal-footer">
                <a id="customerInfoLink" class="btn-primary" target="_blank" rel="noopener">顧客詳細を開く</a>
                <button class="btn-secondary" onclick="closeCustomerInfoModal()">閉じる</button>
            </div>
        </div>
    </div>

    <!-- クイックブロック(時間選択シート) -->
    <div class="modal" id="quickBlockSheet" role="dialog" aria-modal="true" aria-labelledby="quickBlockTitle">
        <div class="modal-content" tabindex="-1">
            <div class="modal-header" id="quickBlockTitle">時間選択シート</div>
            <div class="modal-body">
                <label for="quickBlockDate">日付</label>
                <select id="quickBlockDate"></select>
                <label for="quickBlockStart">開始時刻</label>
                <select id="quickBlockStart"></select>
                <label for="quickBlockDuration">ブロック時間</label>
                <select id="quickBlockDuration">
                    <option value="15" selected>15分</option>
                    <option value="30">30分</option>
                    <option value="45">45分</option>
                    <option value="60">60分</option>
                    <option value="75">75分</option>
                    <option value="90">90分</option>
                    <option value="105">105分</option>
                    <option value="120">120分</option>
                </select>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="document.getElementById('quickBlockSheet').classList.remove('active'); document.body.style.overflow='';">キャンセル</button>
                <button class="btn-primary" id="quickBlockConfirmBtn">ブロック設定</button>
            </div>
        </div>
    </div>

    <script>
        // グローバル変数
        let currentWeek = 0;
        let selectedServiceType = null; // 'visit' or 'store'
        let selectedMenu = null;
        let bookings = [];
        let blocks = [];
        let dragStart = null;
        let dragEnd = null;
        let isDragging = false;
        let selectedBookingId = null;
        let selectedBlockSlot = null;
        let currentBookingForInfo = null;
        
        // インターバル時間設定
        let intervalVisitApplied = 30;
        let intervalVisitPending = 30;
        let intervalStoreApplied = 0;
        let intervalStorePending = 0;
        
        // タッチ用
        let touchLongPressTimer = null;
        let isTouchDragging = false;
        let lastTouchSlot = null;

        const START_HOUR = 9;
        const END_HOUR = 21;
        const INTERVAL = 15;

        // 日本の祝日判定
        function isJapaneseHoliday(date) {
            const year = date.getFullYear();
            const month = date.getMonth() + 1;
            const day = date.getDate();
            const dayOfWeek = date.getDay();

            // 固定祝日
            const fixedHolidays = {
                '1-1': '元日',
                '2-11': '建国記念の日',
                '4-29': '昭和の日',
                '5-3': '憲法記念日',
                '5-4': 'みどりの日',
                '5-5': 'こどもの日',
                '8-11': '山の日',
                '11-3': '文化の日',
                '11-23': '勤労感謝の日',
                '12-23': '天皇誕生日'
            };

            const dateKey = `${month}-${day}`;
            if (fixedHolidays[dateKey]) {
                return true;
            }

            // 春分の日・秋分の日（簡易計算）
            // 2000年から2100年までの簡易計算式
            if (month === 3 && year >= 2000 && year < 2100) {
                // 春分の日: 20.8431 + 0.242194 * (year - 1980) - floor((year - 1980) / 4) の小数点以下を四捨五入
                const springDay = Math.round(20.8431 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
                if (day === springDay) return true;
            }
            if (month === 9 && year >= 2000 && year < 2100) {
                // 秋分の日: 23.2488 + 0.242194 * (year - 1980) - floor((year - 1980) / 4) の小数点以下を四捨五入
                const autumnDay = Math.round(23.2488 + 0.242194 * (year - 1980) - Math.floor((year - 1980) / 4));
                if (day === autumnDay) return true;
            }

            // 移動祝日
            // 成人の日（1月の第2月曜日）
            if (month === 1 && dayOfWeek === 1 && day >= 8 && day <= 14) {
                return true;
            }
            // 海の日
            if (month === 7) {
                if (year === 2020) {
                    // 2020年は7月23日
                    if (day === 23) return true;
                } else if (year === 2021) {
                    // 2021年は7月22日
                    if (day === 22) return true;
                } else if (year >= 2023) {
                    // 2023年以降は7月第3月曜日
                    if (dayOfWeek === 1 && day >= 15 && day <= 21) {
                        return true;
                    }
                } else {
                    // それ以前は7月第3月曜日
                    if (dayOfWeek === 1 && day >= 15 && day <= 21) {
                        return true;
                    }
                }
            }
            // 敬老の日（9月の第3月曜日）
            if (month === 9 && dayOfWeek === 1 && day >= 15 && day <= 21) {
                return true;
            }
            // スポーツの日（10月の第2月曜日）
            if (month === 10) {
                if (year === 2020) {
                    // 2020年は7月24日（実際には10月に表示されない）
                    return false;
                } else if (year === 2021) {
                    // 2021年は7月23日（実際には10月に表示されない）
                    return false;
                } else {
                    // 通常は10月の第2月曜日
                    if (dayOfWeek === 1 && day >= 8 && day <= 14) {
                        return true;
                    }
                }
            }

            return false;
        }

        // 日付ユーティリティ
        function getWeekDates(weekOffset) {
            const today = new Date();
            const currentDay = today.getDay();
            const monday = new Date(today);
            monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1) + (weekOffset * 7));
            
            const dates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(monday);
                date.setDate(monday.getDate() + i);
                dates.push(date);
            }
            return dates;
        }

        function formatDate(date) {
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function formatDateDisplay(date) {
            const month = date.getMonth() + 1;
            const day = date.getDate();
            return `${month}/${day}`;
        }

        function formatWeekInfo(dates) {
            const startDate = dates[0];
            const endDate = dates[6];
            const startYear = startDate.getFullYear();
            const startMonth = startDate.getMonth() + 1;
            const startDay = startDate.getDate();
            const endYear = endDate.getFullYear();
            const endMonth = endDate.getMonth() + 1;
            const endDay = endDate.getDate();
            
            if (startYear !== endYear) {
                return `${startYear}年${startMonth}月${startDay}日〜${endYear}年${endMonth}月${endDay}日`;
            } else if (startMonth !== endMonth) {
                return `${startYear}年${startMonth}月${startDay}日〜${endMonth}月${endDay}日`;
            } else {
                return `${startYear}年${startMonth}月${startDay}日〜${endDay}日`;
            }
        }

        // 週ごとのシフトから最小開始時刻と最大終了時刻を計算
        function getWeekTimeRange(dates) {
            let minStart = null;
            let maxEnd = null;
            
            dates.forEach(date => {
                const dateStr = formatDate(date);
                const shift = shifts.find(s => s.date === dateStr);
                
                if (shift && !shift.allDay) {
                    const startMinutes = timeToMinutes(shift.startTime);
                    const endTime = shift.endTime === '24:00' ? '24:00' : shift.endTime;
                    const endMinutes = endTime === '24:00' ? 24 * 60 : timeToMinutes(endTime);
                    
                    if (minStart === null || startMinutes < minStart) {
                        minStart = startMinutes;
                    }
                    if (maxEnd === null || endMinutes > maxEnd) {
                        maxEnd = endMinutes;
                    }
                }
            });
            
            // シフトがない場合はデフォルト値を使用
            if (minStart === null || maxEnd === null) {
                return { startHour: START_HOUR, endHour: END_HOUR };
            }
            
            // 時刻を時間単位に変換（切り捨て）
            const startHour = Math.floor(minStart / 60);
            // 最大終了時刻を時間単位に変換（切り上げ）
            const endHour = Math.ceil(maxEnd / 60);
            
            return { startHour, endHour: Math.min(24, endHour) };
        }

        function getTimeSlots(dates = null) {
            let startHour = START_HOUR;
            let endHour = END_HOUR;
            
            // 週の日付が指定されている場合は、その週のシフトから時間範囲を計算
            if (dates && dates.length === 7) {
                const range = getWeekTimeRange(dates);
                startHour = range.startHour;
                endHour = range.endHour;
            }
            
            const slots = [];
            for (let hour = startHour; hour < endHour; hour++) {
                for (let min = 0; min < 60; min += INTERVAL) {
                    slots.push(`${String(hour).padStart(2, '0')}:${String(min).padStart(2, '0')}`);
                }
            }
            // 最後の時刻も追加
            slots.push(`${String(endHour).padStart(2, '0')}:00`);
            return slots;
        }

        function timeToMinutes(time) {
            if (time === '24:00') {
                return 24 * 60;
            }
            const [hour, min] = time.split(':').map(Number);
            return hour * 60 + min;
        }

        function minutesToTime(minutes) {
            const hour = Math.floor(minutes / 60);
            const min = minutes % 60;
            return `${String(hour).padStart(2, '0')}:${String(min).padStart(2, '0')}`;
        }

        function getMenuDuration(menuId) {
            return menuId === 1 ? 45 : 60;
        }

        function getServiceTypeName(type) {
            return type === 'visit' ? '🚗 訪問施術' : '🏠 店舗施術';
        }

        // 施術タイプに応じたインターバル選択肢を生成
        function getIntervalOptions(serviceType) {
            if (serviceType === 'visit') {
                // 訪問施術: 0分から15分刻みで120分まで
                return [0, 15, 30, 45, 60, 75, 90, 105, 120];
            } else {
                // 店舗施術: 0分、15分、30分
                return [0, 15, 30];
            }
        }

        // インターバル選択肢のHTML生成
        function generateIntervalOptionsHTML(serviceType, selectedValue) {
            const options = getIntervalOptions(serviceType);
            return options.map(val => {
                const label = val === 0 ? 'インターバルなし' : `${val}分`;
                const selected = val === selectedValue ? 'selected' : '';
                return `<option value="${val}" ${selected}>${label}</option>`;
            }).join('');
        }

        // 指定された予約の前後のインターバルを計算
        function getIntervalsAroundBooking(booking) {
            const dateStr = booking.date;
            const thisStart = timeToMinutes(booking.startTime);
            const thisEnd = timeToMinutes(booking.endTime);
            
            let beforeInterval = null; // 前の予約との間隔
            let afterInterval = null;  // 次の予約との間隔
            
            // 同じ日の他の予約を確認
            const sameDayBookings = bookings.filter(b => 
                b.date === dateStr && 
                b.id !== booking.id && 
                b.status !== 'rejected'
            ).sort((a, b) => timeToMinutes(a.startTime) - timeToMinutes(b.startTime));
            
            sameDayBookings.forEach(other => {
                const otherStart = timeToMinutes(other.startTime);
                const otherEnd = timeToMinutes(other.endTime);
                
                // この予約の前にある予約
                if (otherEnd <= thisStart) {
                    const gap = thisStart - otherEnd;
                    if (beforeInterval === null || gap < beforeInterval) {
                        beforeInterval = gap;
                    }
                }
                // この予約の後にある予約
                else if (otherStart >= thisEnd) {
                    const gap = otherStart - thisEnd;
                    if (afterInterval === null || gap < afterInterval) {
                        afterInterval = gap;
                    }
                }
            });
            
            return { beforeInterval, afterInterval };
        }

        // 特定の時間スロットでのインターバル情報を取得（施術者画面表示用）
        function getIntervalInfoAtSlot(date, time) {
            const dateStr = formatDate(date);
            const slotMinutes = timeToMinutes(time);
            
            // このスロットに予約があるか確認
            const booking = getBookingAtSlot(date, time);
            if (!booking) return null;
            
            // この予約の先頭スロットでのみインターバル情報を表示
            if (timeToMinutes(booking.startTime) !== slotMinutes) return null;
            
            const intervals = getIntervalsAroundBooking(booking);
            // 前後のインターバル時間を取得（個別設定がある場合はそれを使用、なければintervalDurationを使用）
            const requiredBefore = (typeof booking.intervalBefore === 'number' && booking.intervalBeforeActive !== false) ? booking.intervalBefore : (booking.intervalDuration || 0);
            const requiredAfter = (typeof booking.intervalAfter === 'number' && booking.intervalAfterActive !== false) ? booking.intervalAfter : (booking.intervalDuration || 0);
            
            return { 
                booking, 
                beforeInterval: intervals.beforeInterval,
                afterInterval: intervals.afterInterval,
                requiredBefore,
                requiredAfter
            };
        }

        // インターバルブロックを取得（指定されたスロットがインターバルブロックか判定）
        function getIntervalBlockAtSlot(date, time) {
            const dateStr = formatDate(date);
            const slotMinutes = timeToMinutes(time);
            
            // 全ての予約をチェック
            for (const booking of bookings) {
                if (booking.date !== dateStr || booking.status === 'rejected') continue;
                
                const coreStart = timeToMinutes(booking.startTime);
                const coreEnd = timeToMinutes(booking.endTime);
                
                // 前後のインターバル時間を取得（個別設定がある場合はそれを使用、なければintervalDurationを使用）
                const intervalBefore = (typeof booking.intervalBefore === 'number' ? booking.intervalBefore : (booking.intervalDuration || 0));
                const intervalAfter = (typeof booking.intervalAfter === 'number' ? booking.intervalAfter : (booking.intervalDuration || 0));
                
                // 前のインターバルが有効かチェック（0分の場合は非表示）
                if (intervalBefore > 0 && booking.intervalBeforeActive !== false) {
                    const beforeStart = Math.max(START_HOUR * 60, coreStart - intervalBefore);
                    const beforeEnd = coreStart;
                    
                    // このスロットが前のインターバルに該当するか
                    if (slotMinutes >= beforeStart && slotMinutes < beforeEnd) {
                        return { booking, type: 'before', interval: intervalBefore };
                    }
                }
                
                // 後のインターバルが有効かチェック（0分の場合は非表示）
                if (intervalAfter > 0 && booking.intervalAfterActive !== false) {
                    const afterStart = coreEnd;
                    const afterEnd = Math.min(END_HOUR * 60, coreEnd + intervalAfter);
                    
                    // このスロットが後のインターバルに該当するか
                    if (slotMinutes >= afterStart && slotMinutes < afterEnd) {
                        return { booking, type: 'after', interval: intervalAfter };
                    }
                }
            }
            
            return null;
        }

        // インターバルブロックがあるか確認（予約可能性判定用）
        function isIntervalBlocked(date, time) {
            return getIntervalBlockAtSlot(date, time) !== null;
        }

        // 永続化: 保存
        function persistState() {
            localStorage.setItem('rcs_bookings', JSON.stringify(bookings));
            localStorage.setItem('rcs_blocks', JSON.stringify(blocks));
            try { 
                localStorage.setItem('rcs_interval_visit_applied', String(intervalVisitApplied)); 
                localStorage.setItem('rcs_interval_store_applied', String(intervalStoreApplied)); 
            } catch (e) {}
        }

        // 検証用: データリセット
        function resetData() {
            if (!confirm('保存データ(予約・ブロック・シフト・パターン)をすべて削除して初期状態に戻します。よろしいですか?')) return;
            try {
                localStorage.removeItem('rcs_bookings');
                localStorage.removeItem('rcs_blocks');
                localStorage.removeItem('rcs_interval_visit_applied');
                localStorage.removeItem('rcs_interval_store_applied');
                localStorage.removeItem('rcs_shifts');
                localStorage.removeItem('rcs_patterns');
            } catch (e) {}
            bookings = [];
            blocks = [];
            shifts = [];
            patterns = [];
            selectedMenu = null;
            selectedServiceType = null;
            
            document.querySelectorAll('.menu-option').forEach(o => o.classList.remove('selected'));
            renderShiftCalendar();
            updateSummary();
            updateBlocksFromShifts();
            renderCalendar(true);
            renderCalendar(false);
            updatePendingBadge();
            alert('データをリセットしました。');
        }

        // 永続化: 復元
        function restoreState() {
            try {
                bookings = JSON.parse(localStorage.getItem('rcs_bookings') || '[]');
                blocks = JSON.parse(localStorage.getItem('rcs_blocks') || '[]');
                
                // マイグレーション: serviceType, intervalDuration がない場合に補完、前後インターバルを追加
                if (Array.isArray(bookings) && bookings.length > 0) {
                    let mutated = false;
                    bookings = bookings.map(b => {
                        const intervalDuration = typeof b.intervalDuration === 'number' ? b.intervalDuration : 15;
                        const hasIntervalBefore = typeof b.intervalBefore === 'number';
                        const hasIntervalAfter = typeof b.intervalAfter === 'number';
                        const hasBeforeActive = typeof b.intervalBeforeActive === 'boolean';
                        const hasAfterActive = typeof b.intervalAfterActive === 'boolean';
                        
                        // 既にすべてのフィールドがある場合はそのまま返す
                        if (hasIntervalBefore && hasIntervalAfter && hasBeforeActive && hasAfterActive) {
                            return b;
                        }
                        
                        mutated = true;
                        return {
                            id: b.id,
                            date: b.date,
                            startTime: b.startTime,
                            endTime: b.endTime,
                            serviceType: b.serviceType || 'store',
                            menuId: b.menuId,
                            intervalDuration: intervalDuration,
                            intervalBefore: hasIntervalBefore ? b.intervalBefore : intervalDuration,
                            intervalAfter: hasIntervalAfter ? b.intervalAfter : intervalDuration,
                            intervalBeforeActive: hasBeforeActive ? b.intervalBeforeActive : (intervalDuration > 0),
                            intervalAfterActive: hasAfterActive ? b.intervalAfterActive : (intervalDuration > 0),
                            status: b.status || 'pending',
                            comment: b.comment || '',
                            customerName: b.customerName || 'ゲスト',
                            customerContact: b.customerContact || '未登録',
                            customerDetailUrl: b.customerDetailUrl || ''
                        };
                    });
                    if (mutated) { 
                        try { localStorage.setItem('rcs_bookings', JSON.stringify(bookings)); } catch (e) {} 
                    }
                }
                
                // インターバル時間の復元
                const storedVisit = parseInt(localStorage.getItem('rcs_interval_visit_applied') || '30', 10);
                const storedStore = parseInt(localStorage.getItem('rcs_interval_store_applied') || '0', 10);
                if (!isNaN(storedVisit)) {
                    intervalVisitApplied = storedVisit;
                    intervalVisitPending = storedVisit;
                }
                if (!isNaN(storedStore)) {
                    intervalStoreApplied = storedStore;
                    intervalStorePending = storedStore;
                }
            } catch (e) {
                bookings = [];
                blocks = [];
            }
        }

        // ブロック確認
        function isBlocked(date, time) {
            const dateStr = formatDate(date);
            return blocks.some(block => 
                block.date === dateStr && 
                timeToMinutes(time) >= timeToMinutes(block.startTime) && 
                timeToMinutes(time) < timeToMinutes(block.endTime)
            );
        }

        // 範囲内がすべてブロック済みかチェック
        function isAllBlockedInRange(dateStr, startTime, endTime) {
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const dates = getWeekDates(currentWeek);
            const slots = getTimeSlots(dates);
            
            for (let i = 0; i < slots.length - 1; i++) {
                const slotTime = slots[i];
                const slotMinutes = timeToMinutes(slotTime);
                
                if (slotMinutes >= startMinutes && slotMinutes < endMinutes) {
                    const date = new Date(dateStr + 'T00:00:00');
                    if (!isBlocked(date, slotTime)) {
                        return false;
                    }
                }
            }
            return true;
        }

        // 予約確認(不承認は除外)
        function getBookingAtSlot(date, time) {
            const dateStr = formatDate(date);
            return bookings.find(booking => 
                booking.status !== 'rejected' &&
                booking.date === dateStr && 
                timeToMinutes(time) >= timeToMinutes(booking.startTime) && 
                timeToMinutes(time) < timeToMinutes(booking.endTime)
            );
        }

        // 予約可能チェック(インターバル型)
        function canBook(date, startTime, duration, serviceType) {
            if (!serviceType) return false;
            
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = startMinutes + duration;
            
            // 週の表示範囲を取得
            const dates = getWeekDates(currentWeek);
            const slots = getTimeSlots(dates);
            
            // コアが表示範囲内に収まらない場合は不可
            const lastSlot = slots[slots.length - 1];
            const lastSlotMinutes = lastSlot === '24:00' ? 24 * 60 : timeToMinutes(lastSlot);
            if (endMinutes > lastSlotMinutes) {
                return false;
            }
            
            // コア時間帯のスロットチェック
            for (let i = 0; i < slots.length - 1; i++) {
                const slotTime = slots[i];
                const slotMinutes = timeToMinutes(slotTime);
                if (slotMinutes >= startMinutes && slotMinutes < endMinutes) {
                    if (isBlocked(date, slotTime) || getBookingAtSlot(date, slotTime) || isIntervalBlocked(date, slotTime)) {
                        return false;
                    }
                }
            }
            
            // インターバルチェック: 前後の予約とのインターバルが確保されているか
            const intervalDuration = serviceType === 'visit' ? intervalVisitApplied : intervalStoreApplied;
            const dateStr = formatDate(date);
            
            for (const booking of bookings) {
                if (booking.date !== dateStr || booking.status === 'rejected') continue;
                
                const bStart = timeToMinutes(booking.startTime);
                const bEnd = timeToMinutes(booking.endTime);
                
                // 予約の前にこの予約が来る場合（既存予約の後のインターバルをチェック）
                if (endMinutes <= bStart) {
                    const gap = bStart - endMinutes;
                    // 既存予約の後のインターバル時間を取得
                    const bookingIntervalAfter = (typeof booking.intervalAfter === 'number' && booking.intervalAfterActive !== false) ? booking.intervalAfter : (booking.intervalDuration || 0);
                    // 新しい予約の前のインターバル時間（デフォルト値を使用）
                    const requiredInterval = Math.max(intervalDuration, bookingIntervalAfter);
                    if (gap < requiredInterval) {
                        return false;
                    }
                }
                // この予約の前に既存予約が来る場合（既存予約の後のインターバルと新しい予約の前のインターバルをチェック）
                else if (bEnd <= startMinutes) {
                    const gap = startMinutes - bEnd;
                    // 既存予約の後のインターバル時間を取得
                    const bookingIntervalAfter = (typeof booking.intervalAfter === 'number' && booking.intervalAfterActive !== false) ? booking.intervalAfter : (booking.intervalDuration || 0);
                    // 新しい予約の前のインターバル時間（デフォルト値を使用）
                    const requiredInterval = Math.max(intervalDuration, bookingIntervalAfter);
                    if (gap < requiredInterval) {
                        return false;
                    }
                }
            }
            
            return true;
        }

        // カレンダー描画 - メイン関数
        function renderCalendar(isProvider) {
            const dates = getWeekDates(currentWeek);
            const calendarId = isProvider ? 'providerCalendar' : 'customerCalendar';
            const calendar = document.getElementById(calendarId);
            const weekInfo = document.getElementById(isProvider ? 'weekInfoProvider' : 'weekInfoCustomer');
            
            weekInfo.textContent = formatWeekInfo(dates);
            
            if (isProvider) {
                calendar.innerHTML = renderProviderCalendar(dates);
                attachProviderEvents();
            } else {
                calendar.innerHTML = renderCustomerCalendarMobile(dates);
                attachCustomerEvents();
            }
        }

        // 施術者画面 - 15分刻み全表示
        function renderProviderCalendar(dates) {
            const slots = getTimeSlots(dates);
            const dayNames = ['月', '火', '水', '木', '金', '土', '日'];
            
            let html = '<thead><tr><th>時間</th>';
            dates.forEach((date, i) => {
                const dayOfWeek = date.getDay(); // 0=日曜、6=土曜
                const isHoliday = isJapaneseHoliday(date);
                let headerClass = 'date-header';
                if (isHoliday || dayOfWeek === 0) {
                    headerClass += ' holiday'; // 祝日または日曜日
                } else if (dayOfWeek === 6) {
                    headerClass += ' saturday'; // 土曜日
                }
                html += `<th class="${headerClass}">
                    <span class="day-name">${dayNames[i]}</span>
                    <span class="date-num">${formatDateDisplay(date)}</span>
                    <button class="block-all-btn" data-date="${formatDate(date)}">終日ブロック</button>
                </th>`;
            });
            html += '</tr></thead><tbody>';
            
            slots.slice(0, -1).forEach(time => {
                html += `<tr><td class="time-label">${time}</td>`;
                dates.forEach(date => {
                    html += renderProviderTimeSlot(date, time);
                });
                html += '</tr>';
            });
            
            html += '</tbody>';
            return html;
        }

        // 施術者画面 - 個別タイムスロット
        function renderProviderTimeSlot(date, time) {
            const dateStr = formatDate(date);
            const displayDate = formatDateDisplay(date);
            const blocked = isBlocked(date, time);
            const booking = getBookingAtSlot(date, time);
            const intervalBlock = getIntervalBlockAtSlot(date, time);
            
            let className = 'time-slot';
            let content = '';
            let dataAttrs = `data-date="${dateStr}" data-time="${time}"`;
            let title = '';
            let intervalIndicator = '';
            
            // インターバルブロックの場合
            if (intervalBlock && !booking) {
                className += ' interval';
                content = 'インターバル';
                title = `インターバル: ${intervalBlock.interval}分`;
                dataAttrs += ` data-booking-id="${intervalBlock.booking.id}" data-interval-type="${intervalBlock.type}"`;
            } else if (booking) {
                const slotMinutes = timeToMinutes(time);
                const startM = timeToMinutes(booking.startTime);
                const endM = timeToMinutes(booking.endTime);
                
                // インターバル情報を取得（先頭スロットのみ）
                const intervalInfo = getIntervalInfoAtSlot(date, time);
                if (intervalInfo) {
                    const { beforeInterval, afterInterval, requiredBefore, requiredAfter } = intervalInfo;
                    let intervalText = '';
                    let intervalClass = 'ok';
                    
                    // 前のインターバル
                    if (beforeInterval !== null && requiredBefore > 0) {
                        if (beforeInterval < requiredBefore) {
                            intervalClass = 'error';
                            intervalText = `前${beforeInterval}分`;
                        } else {
                            intervalText = `前${beforeInterval}分`;
                        }
                    }
                    // 後のインターバル
                    if (afterInterval !== null && requiredAfter > 0) {
                        if (afterInterval < requiredAfter) {
                            intervalClass = 'error';
                            intervalText += (intervalText ? '/' : '') + `後${afterInterval}分`;
                        } else {
                            intervalText += (intervalText ? '/' : '') + `後${afterInterval}分`;
                        }
                    }
                    
                    if (intervalText) {
                        intervalIndicator = `<span class="interval-indicator ${intervalClass}">${intervalText}</span>`;
                    }
                }
                
                if (booking.status === 'pending') {
                    className += ' pending';
                    content = '承認待ち';
                    title = `承認待ち: 施術 ${booking.startTime}〜${booking.endTime}`;
                } else if (booking.status === 'confirmed') {
                    className += ' confirmed';
                    content = '予約済';
                    title = `予約済み: 施術 ${booking.startTime}〜${booking.endTime}`;
                } else if (booking.status === 'rejected') {
                    className += ' rejected';
                    content = '不承認';
                    title = '不承認';
                }
                dataAttrs += ` data-booking-id="${booking.id}"`;
            } else if (blocked) {
                className += ' blocked removable';
                content = '×';
                title = 'ブロック(手動)—クリックで解除';
            } else {
                className += ' available';
                content = '◯';
                title = '受付可能—ドラッグでブロック設定';
            }
            
            return `<td><div class="${className}" ${dataAttrs} title="${title}">${content}${intervalIndicator}</div></td>`;
        }

        // 利用者画面 - モバイル用: ホットペッパー風(15分グリッド)
        function renderCustomerCalendarMobile(dates) {
            const slots = getTimeSlots(dates);
            const dayNames = ['月', '火', '水', '木', '金', '土', '日'];
            let html = '<table class="hp-table">';
            html += '<thead><tr><th class="hp-time">日時</th>';
            dates.forEach((date, i) => {
                const dayOfWeek = date.getDay(); // 0=日曜、6=土曜
                const isHoliday = isJapaneseHoliday(date);
                let headerClass = '';
                if (isHoliday || dayOfWeek === 0) {
                    headerClass = ' holiday sunday'; // 祝日または日曜日
                } else if (dayOfWeek === 6) {
                    headerClass = ' saturday'; // 土曜日
                }
                html += `<th class="${headerClass.trim()}">${dayNames[i]}<br>${formatDateDisplay(date)}</th>`;
            });
            html += '</tr></thead><tbody>';
            
            const duration = selectedMenu ? getMenuDuration(selectedMenu) : null;
            
            slots.slice(0, -1).forEach(time => {
                html += `<tr>`;
                html += `<td class="hp-time">${time}</td>`;
                dates.forEach(date => {
                    let inner = '-';
                    if (selectedMenu && selectedServiceType) {
                        if (canBook(date, time, duration, selectedServiceType)) {
                            inner = `<div class="hp-cell available" onclick="handleCustomerSlotClick('${formatDate(date)}','${time}')">◯</div>`;
                        } else {
                            inner = `<div class="hp-cell blocked">×</div>`;
                        }
                    } else {
                        inner = `<div class="hp-cell">-</div>`;
                    }
                    html += `<td class="hp-slot">${inner}</td>`;
                });
                html += `</tr>`;
            });
            
            html += '</tbody></table>';
            return `<div class="hp-calendar">${html}</div>`;
        }

        // 利用者 - スロットクリック
        function handleCustomerSlotClick(date, time) {
            if (!selectedServiceType) {
                alert('施術タイプ(訪問施術/店舗施術)を選択してください');
                return;
            }
            if (!selectedMenu) {
                alert('施術メニューを選択してください');
                return;
            }
            showBookingModal(date, time);
        }

        // 施術者画面イベント
        function attachProviderEvents() {
            const slots = document.querySelectorAll('#provider-content .time-slot');
            
            slots.forEach(slot => {
                // ドラッグ&ドロップ
                slot.addEventListener('mousedown', handleDragStart);
                slot.addEventListener('mouseenter', handleDragOver);
                slot.addEventListener('mouseup', handleDragEnd);
                // タッチ対応(長押し→ドラッグ)
                slot.addEventListener('touchstart', handleTouchStart, { passive: false });
                slot.addEventListener('touchmove', handleTouchMove, { passive: false });
                slot.addEventListener('touchend', handleTouchEnd);
                
                // 承認待ちクリック
                if (slot.classList.contains('pending')) {
                    slot.addEventListener('click', handlePendingClick);
                }
                // 予約済みクリック(顧客情報ポップ)
                if (slot.classList.contains('confirmed')) {
                    slot.addEventListener('click', handleConfirmedClick);
                }
                
                // ブロック解除
                if (slot.classList.contains('removable')) {
                    slot.addEventListener('click', handleBlockRemove);
                }
            });

            // 終日ブロックボタン
            const blockAllBtns = document.querySelectorAll('.block-all-btn');
            blockAllBtns.forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    handleBlockAllDay(btn.dataset.date);
                });
            });

            // クイックブロックシート
            const openQuick = document.getElementById('openQuickBlockSheet');
            if (openQuick) {
                openQuick.addEventListener('click', openQuickBlockSheet);
            }
        }

        // 利用者画面イベント(既にonclick属性で設定済み)
        function attachCustomerEvents() {
            // 必要に応じて追加のイベントリスナーを設定
        }

        // ブロック解除(1枠毎に解除)
        function handleBlockRemove(e) {
            e.stopPropagation();
            const slot = e.target;
            const date = slot.dataset.date;
            const time = slot.dataset.time;
            
            const timeMinutes = timeToMinutes(time);
            const newBlocks = [];
            
            blocks.forEach(block => {
                if (block.date !== date) {
                    newBlocks.push(block);
                    return;
                }
                
                const blockStart = timeToMinutes(block.startTime);
                const blockEnd = timeToMinutes(block.endTime);
                
                if (timeMinutes >= blockStart && timeMinutes < blockEnd) {
                    if (blockStart < timeMinutes) {
                        newBlocks.push({
                            id: Date.now() + Math.random(),
                            date: block.date,
                            startTime: block.startTime,
                            endTime: time
                        });
                    }
                    if (timeMinutes + INTERVAL < blockEnd) {
                        newBlocks.push({
                            id: Date.now() + Math.random(),
                            date: block.date,
                            startTime: minutesToTime(timeMinutes + INTERVAL),
                            endTime: block.endTime
                        });
                    }
                } else {
                    newBlocks.push(block);
                }
            });
            
            blocks = newBlocks;
            persistState();
            renderCalendar(true);
            renderCalendar(false);
        }

        // 終日ブロック
        function handleBlockAllDay(dateStr) {
            const [year, month, day] = dateStr.split('-').map(Number);
            const displayDate = `${month}/${day}`;
            
            if (!confirm(`${displayDate}を終日ブロックしますか?`)) {
                return;
            }
            
            blocks = blocks.filter(block => block.date !== dateStr);
            
            blocks.push({
                id: Date.now(),
                date: dateStr,
                startTime: `${String(START_HOUR).padStart(2, '0')}:00`,
                endTime: `${String(END_HOUR).padStart(2, '0')}:00`
            });
            
            persistState();
            renderCalendar(true);
            renderCalendar(false);
        }

        // ドラッグ開始
        function handleDragStart(e) {
            const slot = e.target;
            if (slot.classList.contains('pending') || 
                slot.classList.contains('confirmed') ||
                (slot.classList.contains('blocked') && !slot.classList.contains('removable'))) {
                return;
            }
            
            isDragging = true;
            dragStart = { date: slot.dataset.date, time: slot.dataset.time };
            slot.classList.add('dragging');
        }

        // ドラッグ中
        function handleDragOver(e) {
            if (!isDragging) return;
            const slot = e.target;
            if (!slot.classList.contains('time-slot')) return;
            if (slot.classList.contains('pending') || 
                slot.classList.contains('confirmed') ||
                (slot.classList.contains('blocked') && !slot.classList.contains('removable'))) {
                return;
            }
            
            slot.classList.add('dragging');
        }

        // 範囲内のブロックを解除する
        function removeBlocksInRange(dateStr, startTime, endTime) {
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            const newBlocks = [];
            
            blocks.forEach(block => {
                if (block.date !== dateStr) {
                    newBlocks.push(block);
                    return;
                }
                
                const blockStart = timeToMinutes(block.startTime);
                const blockEnd = timeToMinutes(block.endTime);
                
                const overlapStart = Math.max(blockStart, startMinutes);
                const overlapEnd = Math.min(blockEnd, endMinutes);
                
                if (overlapStart < overlapEnd) {
                    if (blockStart < overlapStart) {
                        newBlocks.push({
                            id: Date.now() + Math.random(),
                            date: block.date,
                            startTime: block.startTime,
                            endTime: minutesToTime(overlapStart)
                        });
                    }
                    if (overlapEnd < blockEnd) {
                        newBlocks.push({
                            id: Date.now() + Math.random() + 1,
                            date: block.date,
                            startTime: minutesToTime(overlapEnd),
                            endTime: block.endTime
                        });
                    }
                } else {
                    newBlocks.push(block);
                }
            });
            
            blocks = newBlocks;
        }

        // ドラッグ終了
        function handleDragEnd(e) {
            if (!isDragging) return;
            
            const slot = e.target;
            if (!slot.classList.contains('time-slot')) {
                isDragging = false;
                clearDragging();
                return;
            }
            
            dragEnd = { date: slot.dataset.date, time: slot.dataset.time };
            
            if (dragStart.date !== dragEnd.date) {
                alert('同じ日付内でのみブロック設定できます');
                isDragging = false;
                clearDragging();
                return;
            }
            
            let startTime = dragStart.time;
            let endTime = dragEnd.time;
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            
            if (startMinutes > endMinutes) {
                [startTime, endTime] = [endTime, startTime];
            }
            
            const actualEndMinutes = timeToMinutes(endTime) + INTERVAL;
            const actualEndTime = minutesToTime(actualEndMinutes);
            
            if (isAllBlockedInRange(dragStart.date, startTime, actualEndTime)) {
                removeBlocksInRange(dragStart.date, startTime, actualEndTime);
                persistState();
                renderCalendar(true);
                renderCalendar(false);
            } else {
                dragEnd = { date: dragStart.date, time: endTime };
                showBlockModal();
            }
            
            isDragging = false;
        }

        // タッチ: 長押し開始
        function handleTouchStart(e) {
            const slot = e.currentTarget;
            if (slot.classList.contains('pending') || slot.classList.contains('confirmed')) return;
            if (slot.classList.contains('blocked') && !slot.classList.contains('removable')) return;
            if (touchLongPressTimer) clearTimeout(touchLongPressTimer);
            lastTouchSlot = null;
            isTouchDragging = false;
            touchLongPressTimer = setTimeout(() => {
                isTouchDragging = true;
                isDragging = true;
                dragStart = { date: slot.dataset.date, time: slot.dataset.time };
                slot.classList.add('dragging');
            }, 450);
        }

        // タッチ: ドラッグ中
        function handleTouchMove(e) {
            if (!isTouchDragging) {
                if (touchLongPressTimer) e.preventDefault();
                return;
            }
            e.preventDefault();
            const touch = e.touches[0];
            const el = document.elementFromPoint(touch.clientX, touch.clientY);
            if (!el) return;
            const slot = el.closest && el.closest('.time-slot');
            if (!slot) return;
            if (slot.dataset.date !== dragStart.date) return;
            if (slot.classList.contains('pending') || slot.classList.contains('confirmed')) return;
            if (slot.classList.contains('blocked') && !slot.classList.contains('removable')) return;
            if (lastTouchSlot === slot) return;
            lastTouchSlot = slot;
            slot.classList.add('dragging');
        }

        // タッチ: 終了
        function handleTouchEnd() {
            if (touchLongPressTimer) {
                clearTimeout(touchLongPressTimer);
                touchLongPressTimer = null;
            }
            if (!isTouchDragging) return;
            isTouchDragging = false;
            if (!isDragging) return;
            const slot = lastTouchSlot;
            if (!dragStart || !slot) { 
                clearDragging(); 
                isDragging = false; 
                dragStart = null; 
                dragEnd = null; 
                return; 
            }
            dragEnd = { date: slot.dataset.date, time: slot.dataset.time };
            if (dragStart.date !== dragEnd.date) {
                alert('同じ日付内でのみブロック設定できます');
                isDragging = false;
                clearDragging();
                dragStart = null; 
                dragEnd = null;
                return;
            }
            let startTime = dragStart.time;
            let endTime = dragEnd.time;
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = timeToMinutes(endTime);
            if (startMinutes > endMinutes) [startTime, endTime] = [endTime, startTime];
            const actualEndMinutes = timeToMinutes(endTime) + INTERVAL;
            const actualEndTime = minutesToTime(actualEndMinutes);
            if (isAllBlockedInRange(dragStart.date, startTime, actualEndTime)) {
                removeBlocksInRange(dragStart.date, startTime, actualEndTime);
                persistState();
                renderCalendar(true);
                renderCalendar(false);
            } else {
                dragEnd = { date: dragStart.date, time: endTime };
                showBlockModal();
            }
            isDragging = false;
            clearDragging();
        }

        function clearDragging() {
            document.querySelectorAll('.dragging').forEach(el => {
                el.classList.remove('dragging');
            });
        }

        // ブロックモーダル
        function showBlockModal() {
            const modal = document.getElementById('blockModal');
            const dates = getWeekDates(currentWeek);
            const date = dates.find(d => formatDate(d) === dragStart.date);
            
            const startTime = dragStart.time;
            const endTime = dragEnd ? dragEnd.time : startTime;
            const duration = (timeToMinutes(endTime) - timeToMinutes(startTime) + INTERVAL);
            
            document.getElementById('blockDateTime').textContent = 
                `${date.getMonth() + 1}月${date.getDate()}日 ${startTime}〜`;
            document.getElementById('blockDuration').value = duration;
            
            selectedBlockSlot = { date: dragStart.date, startTime, duration };
            openModal(modal, { primary: confirmBlock });
            clearDragging();
        }

        function closeBlockModal() {
            document.getElementById('blockModal').classList.remove('active');
            selectedBlockSlot = null;
            clearDragging();
            document.body.style.overflow = '';
        }

        function confirmBlock() {
            if (!selectedBlockSlot) return;
            
            const duration = parseInt(document.getElementById('blockDuration').value);
            const startMinutes = timeToMinutes(selectedBlockSlot.startTime);
            const endMinutes = Math.min(startMinutes + duration, END_HOUR * 60);
            const endTime = minutesToTime(endMinutes);
            
            if (startMinutes + duration > END_HOUR * 60) {
                alert(`営業時間は${END_HOUR}:00までです。ブロック時間を${endTime}まで調整しました。`);
            }
            
            blocks.push({
                id: Date.now(),
                date: selectedBlockSlot.date,
                startTime: selectedBlockSlot.startTime,
                endTime: endTime
            });
            
            closeBlockModal();
            persistState();
            renderCalendar(true);
            renderCalendar(false);
        }

        // 予約モーダル
        function showBookingModal(date, time) {
            const modal = document.getElementById('bookingModal');
            const dates = getWeekDates(currentWeek);
            const dateObj = dates.find(d => formatDate(d) === date);
            const duration = getMenuDuration(selectedMenu);
            const menuName = selectedMenu === 1 ? '施術①' : '施術②';
            const typeName = getServiceTypeName(selectedServiceType);

            document.getElementById('bookingType').textContent = typeName;
            document.getElementById('bookingMenu').textContent = `${menuName}(${duration}分)`;
            document.getElementById('bookingDateTime').textContent = 
                `${dateObj.getMonth() + 1}月${dateObj.getDate()}日(${['日','月','火','水','木','金','土'][dateObj.getDay()]})${time}〜${minutesToTime(timeToMinutes(time) + duration)}`;
            document.getElementById('bookingDuration').textContent = `${duration}分`;
            
            selectedBookingId = { date, time, menuId: selectedMenu, duration, serviceType: selectedServiceType };
            openModal(modal, { primary: confirmBooking });
        }

        function closeBookingModal() {
            document.getElementById('bookingModal').classList.remove('active');
            selectedBookingId = null;
            document.body.style.overflow = '';
        }

        function confirmBooking() {
            if (!selectedBookingId) return;
            
            const { date, time, menuId, duration, serviceType } = selectedBookingId;
            const startMinutes = timeToMinutes(time);
            const endMinutes = startMinutes + duration;
            
            // インターバル時間を取得（前後は同じ値で初期化）
            const intervalDuration = serviceType === 'visit' ? intervalVisitApplied : intervalStoreApplied;
            
            // 予約レコード(承認待ち)を作成
            const booking = {
                id: Date.now(),
                date: date,
                startTime: time,
                endTime: minutesToTime(endMinutes),
                serviceType: serviceType,
                menuId: menuId,
                intervalDuration: intervalDuration,
                intervalBefore: intervalDuration,  // 前のインターバル
                intervalAfter: intervalDuration,     // 後のインターバル
                intervalBeforeActive: intervalDuration > 0,  // 前のインターバルが有効か
                intervalAfterActive: intervalDuration > 0,   // 後のインターバルが有効か
                status: 'pending',
                comment: '',
                customerName: 'ゲスト',
                customerContact: '未登録',
                customerDetailUrl: `https://example.com/customers?bookingId=${Date.now()}`
            };
            bookings.push(booking);
            
            closeBookingModal();
            persistState();
            renderCalendar(true);
            renderCalendar(false);
            updatePendingBadge();
        }

        // 承認待ちクリック
        function handlePendingClick(e) {
            const slot = e.target;
            const bookingId = parseInt(slot.dataset.bookingId);
            const booking = bookings.find(b => b.id === bookingId);
            
            if (booking) {
                showApprovalModal(booking);
            }
        }

        // 予約済みクリック -> 顧客情報ポップ
        function handleConfirmedClick(e) {
            const slot = e.target;
            const bookingId = parseInt(slot.dataset.bookingId);
            const booking = bookings.find(b => b.id === bookingId);
            if (!booking) return;
            showCustomerInfoModal(booking);
        }

        // 承認モーダル
        function showApprovalModal(booking) {
            const modal = document.getElementById('approvalModal');
            const dates = getWeekDates(currentWeek);
            const date = dates.find(d => formatDate(d) === booking.date);
            const menuName = booking.menuId === 1 ? '施術①' : '施術②';
            const duration = getMenuDuration(booking.menuId);
            const typeName = getServiceTypeName(booking.serviceType);
            
            document.getElementById('approvalType').textContent = typeName;
            document.getElementById('approvalMenu').textContent = `${menuName}(${duration}分)`;
            document.getElementById('approvalDateTime').textContent = 
                `${date.getMonth() + 1}月${date.getDate()}日(${['日','月','火','水','木','金','土'][date.getDay()]})`;
            document.getElementById('approvalCoreTime').textContent = `${booking.startTime}〜${booking.endTime}`;
            
            // 前後のインターバル時間の選択肢を動的生成
            const intervalBeforeSelect = document.getElementById('approvalIntervalBefore');
            const intervalAfterSelect = document.getElementById('approvalIntervalAfter');
            const intervalBefore = typeof booking.intervalBefore === 'number' ? booking.intervalBefore : (booking.intervalDuration || 0);
            const intervalAfter = typeof booking.intervalAfter === 'number' ? booking.intervalAfter : (booking.intervalDuration || 0);
            intervalBeforeSelect.innerHTML = generateIntervalOptionsHTML(booking.serviceType, intervalBefore);
            intervalAfterSelect.innerHTML = generateIntervalOptionsHTML(booking.serviceType, intervalAfter);
            
            document.getElementById('approvalComment').value = '';
            
            selectedBookingId = booking.id;
            openModal(modal, {});
        }

        function closeApprovalModal() {
            document.getElementById('approvalModal').classList.remove('active');
            selectedBookingId = null;
            document.body.style.overflow = '';
        }

        function approveBooking() {
            const booking = bookings.find(b => b.id === selectedBookingId);
            if (booking) {
                booking.status = 'confirmed';
                booking.comment = document.getElementById('approvalComment').value;
                
                // 前後のインターバル時間を個別に設定
                const intervalBefore = parseInt(document.getElementById('approvalIntervalBefore').value) || 0;
                const intervalAfter = parseInt(document.getElementById('approvalIntervalAfter').value) || 0;
                booking.intervalBefore = intervalBefore;
                booking.intervalAfter = intervalAfter;
                booking.intervalBeforeActive = intervalBefore > 0;
                booking.intervalAfterActive = intervalAfter > 0;
                // intervalDurationは前後の最大値に設定（後方互換性のため）
                booking.intervalDuration = Math.max(intervalBefore, intervalAfter);
                
                closeApprovalModal();
                persistState();
                renderCalendar(true);
                renderCalendar(false);
                updatePendingBadge();
                alert('予約を承認しました');
            }
        }

        function rejectBooking() {
            const booking = bookings.find(b => b.id === selectedBookingId);
            if (booking) {
                booking.status = 'rejected';
                booking.comment = document.getElementById('approvalComment').value;
                closeApprovalModal();
                persistState();
                renderCalendar(true);
                renderCalendar(false);
                updatePendingBadge();
                alert('予約を不承認にしました');
            }
        }

        // 顧客情報モーダル
        function showCustomerInfoModal(booking) {
            currentBookingForInfo = booking;
            const modal = document.getElementById('customerInfoModal');
            const dates = getWeekDates(currentWeek);
            const date = dates.find(d => formatDate(d) === booking.date);
            const menuName = booking.menuId === 1 ? '施術①' : '施術②';
            const typeName = getServiceTypeName(booking.serviceType);
            
            document.getElementById('ciName').textContent = booking.customerName || '不明';
            document.getElementById('ciContact').textContent = booking.customerContact || '不明';
            document.getElementById('ciType').textContent = typeName;
            document.getElementById('ciMenu').textContent = menuName;
            document.getElementById('ciDateTime').textContent = `${date.getMonth()+1}月${date.getDate()}日 ${booking.startTime}〜${booking.endTime}`;
            
            // 前後のインターバル時間の選択肢を動的生成
            const intervalBeforeSelect = document.getElementById('ciIntervalBefore');
            const intervalAfterSelect = document.getElementById('ciIntervalAfter');
            const intervalBefore = typeof booking.intervalBefore === 'number' ? booking.intervalBefore : (booking.intervalDuration || 0);
            const intervalAfter = typeof booking.intervalAfter === 'number' ? booking.intervalAfter : (booking.intervalDuration || 0);
            intervalBeforeSelect.innerHTML = generateIntervalOptionsHTML(booking.serviceType, intervalBefore);
            intervalAfterSelect.innerHTML = generateIntervalOptionsHTML(booking.serviceType, intervalAfter);
            
            const link = document.getElementById('customerInfoLink');
            const url = booking.customerDetailUrl || `https://example.com/customers?bookingId=${booking.id}`;
            link.href = url;
            openModal(modal, {});
        }

        function closeCustomerInfoModal() {
            document.getElementById('customerInfoModal').classList.remove('active');
            currentBookingForInfo = null;
            document.body.style.overflow = '';
        }

        // インターバル時間更新（確認ポップアップ付き）
        function updateBookingInterval() {
            if (!currentBookingForInfo) return;
            
            const newIntervalBefore = parseInt(document.getElementById('ciIntervalBefore').value) || 0;
            const newIntervalAfter = parseInt(document.getElementById('ciIntervalAfter').value) || 0;
            
            // 現在の値と比較
            const currentBefore = typeof currentBookingForInfo.intervalBefore === 'number' ? currentBookingForInfo.intervalBefore : (currentBookingForInfo.intervalDuration || 0);
            const currentAfter = typeof currentBookingForInfo.intervalAfter === 'number' ? currentBookingForInfo.intervalAfter : (currentBookingForInfo.intervalDuration || 0);
            
            // 変更がない場合は何もしない
            if (newIntervalBefore === currentBefore && newIntervalAfter === currentAfter) {
                alert('インターバル時間に変更はありません');
                return;
            }
            
            // 確認ポップアップ
            const beforeText = newIntervalBefore === 0 ? 'インターバルなし' : `前${newIntervalBefore}分`;
            const afterText = newIntervalAfter === 0 ? 'インターバルなし' : `後${newIntervalAfter}分`;
            const confirmMsg = `インターバル時間を以下のように変更しますか？\n\n前: ${beforeText}\n後: ${afterText}`;
            
            if (!confirm(confirmMsg)) {
                return;
            }
            
            // 更新
            currentBookingForInfo.intervalBefore = newIntervalBefore;
            currentBookingForInfo.intervalAfter = newIntervalAfter;
            currentBookingForInfo.intervalBeforeActive = newIntervalBefore > 0;
            currentBookingForInfo.intervalAfterActive = newIntervalAfter > 0;
            // intervalDurationは前後の最大値に設定（後方互換性のため）
            currentBookingForInfo.intervalDuration = Math.max(newIntervalBefore, newIntervalAfter);
            
            persistState();
            alert('インターバル時間を更新しました');
            closeCustomerInfoModal();
            renderCalendar(true);
            renderCalendar(false);
        }

        // バッジ更新
        function updatePendingBadge() {
            const dates = getWeekDates(currentWeek);
            const weekDates = dates.map(d => formatDate(d));
            
            const count = bookings.filter(b => 
                b.status === 'pending' && weekDates.includes(b.date)
            ).length;
            
            const badge = document.getElementById('pendingBadge');
            if (count > 0) {
                badge.textContent = count;
                badge.style.display = 'block';
            } else {
                badge.style.display = 'none';
            }
        }

        // タブ切り替え
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tabName}-content`).classList.add('active');
                
                if (tabName === 'shift') {
                    renderShiftCalendar();
                    updateSummary();
                } else {
                    renderCalendar(tabName === 'provider');
                }
            });
        });

        // 施術タイプ選択
        document.querySelectorAll('.menu-option[data-type]').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.menu-option[data-type]').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                selectedServiceType = option.dataset.type;
                renderCalendar(false);
            });
        });

        // メニュー選択
        document.querySelectorAll('.menu-option[data-menu]').forEach(option => {
            option.addEventListener('click', () => {
                document.querySelectorAll('.menu-option[data-menu]').forEach(o => o.classList.remove('selected'));
                option.classList.add('selected');
                selectedMenu = parseInt(option.dataset.menu);
                renderCalendar(false);
            });
        });

        // 週移動
        document.getElementById('prevWeekProvider').addEventListener('click', () => {
            currentWeek--;
            renderCalendar(true);
            updatePendingBadge();
        });

        document.getElementById('nextWeekProvider').addEventListener('click', () => {
            currentWeek++;
            renderCalendar(true);
            updatePendingBadge();
        });

        document.getElementById('prevWeekCustomer').addEventListener('click', () => {
            currentWeek--;
            renderCalendar(false);
            updatePendingBadge();
        });

        document.getElementById('nextWeekCustomer').addEventListener('click', () => {
            currentWeek++;
            renderCalendar(false);
            updatePendingBadge();
        });

        // グローバルマウスアップ
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                clearDragging();
            }
        });

        // 共通モーダル: フォーカストラップ・Esc閉じ・Enter=主要アクション・背景スクロール固定
        function openModal(modalEl, actions) {
            const content = modalEl.querySelector('.modal-content');
            const previouslyFocused = document.activeElement;
            function closeInternal() {
                modalEl.classList.remove('active');
                document.body.style.overflow = '';
                document.removeEventListener('keydown', onKeydown, true);
                if (previouslyFocused && previouslyFocused.focus) previouslyFocused.focus();
            }
            function onKeydown(e) {
                if (e.key === 'Escape') {
                    e.preventDefault();
                    closeInternal();
                } else if (e.key === 'Enter') {
                    const tag = (e.target && e.target.tagName || '').toLowerCase();
                    if (tag !== 'textarea') {
                        e.preventDefault();
                        if (actions && typeof actions.primary === 'function') actions.primary();
                        closeInternal();
                    }
                } else if (e.key === 'Tab') {
                    const focusables = content.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
                    const list = Array.from(focusables).filter(el => !el.hasAttribute('disabled'));
                    if (list.length === 0) return;
                    const first = list[0];
                    const last = list[list.length - 1];
                    if (e.shiftKey && document.activeElement === first) { 
                        e.preventDefault(); 
                        last.focus(); 
                    } else if (!e.shiftKey && document.activeElement === last) { 
                        e.preventDefault(); 
                        first.focus(); 
                    }
                }
            }
            modalEl.classList.add('active');
            document.body.style.overflow = 'hidden';
            document.addEventListener('keydown', onKeydown, true);
            const primary = modalEl.querySelector('.modal-footer .btn-primary');
            setTimeout(() => { (primary || content).focus(); }, 0);
        }

        // クイックブロック(+ボタン→時間選択シート)
        function openQuickBlockSheet() {
            const sheet = document.getElementById('quickBlockSheet');
            const dateSelect = document.getElementById('quickBlockDate');
            const startSelect = document.getElementById('quickBlockStart');
            const durationSelect = document.getElementById('quickBlockDuration');
            
            dateSelect.innerHTML = '';
            const dates = getWeekDates(currentWeek);
            dates.forEach(d => {
                const v = formatDate(d);
                const opt = document.createElement('option');
                opt.value = v; 
                opt.textContent = `${d.getMonth()+1}/${d.getDate()} (${['日','月','火','水','木','金','土'][d.getDay()]})`;
                dateSelect.appendChild(opt);
            });
            
            startSelect.innerHTML = '';
            for (let h = START_HOUR; h <= END_HOUR; h++) {
                for (let m = 0; m < 60; m += INTERVAL) {
                    const t = `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}`;
                    const opt = document.createElement('option');
                    opt.value = t; 
                    opt.textContent = t;
                    startSelect.appendChild(opt);
                }
            }
            durationSelect.value = '15';
            
            const confirmBtn = document.getElementById('quickBlockConfirmBtn');
            const onConfirm = () => {
                const date = dateSelect.value;
                const start = startSelect.value;
                const duration = parseInt(durationSelect.value, 10);
                addBlock(date, start, duration);
                persistState();
                renderCalendar(true);
                renderCalendar(false);
                document.getElementById('quickBlockSheet').classList.remove('active');
                document.body.style.overflow = '';
            };
            confirmBtn.onclick = onConfirm;
            openModal(sheet, { primary: onConfirm });
        }

        function addBlock(dateStr, startTime, duration) {
            const startMinutes = timeToMinutes(startTime);
            const endMinutes = Math.min(startMinutes + duration, END_HOUR * 60);
            const endTime = minutesToTime(endMinutes);
            if (startMinutes >= END_HOUR * 60) {
                alert(`営業時間は${END_HOUR}:00までです`);
                return;
            }
            blocks.push({ id: Date.now(), date: dateStr, startTime, endTime });
        }

        // インターバル設定UIのハンドラ
        (function initIntervalSettingUI(){
            const visitSel = document.getElementById('intervalVisitSelect');
            const visitApplyBtn = document.getElementById('applyIntervalVisitBtn');
            const visitAppliedText = document.getElementById('appliedIntervalVisitText');
            
            const storeSel = document.getElementById('intervalStoreSelect');
            const storeApplyBtn = document.getElementById('applyIntervalStoreBtn');
            const storeAppliedText = document.getElementById('appliedIntervalStoreText');
            
            if (visitSel && visitApplyBtn && visitAppliedText) {
                visitSel.value = String(intervalVisitApplied);
                visitAppliedText.textContent = String(intervalVisitApplied);
                visitSel.addEventListener('change', () => {
                    intervalVisitPending = parseInt(visitSel.value, 10);
                });
                visitApplyBtn.addEventListener('click', () => {
                    intervalVisitApplied = intervalVisitPending;
                    visitAppliedText.textContent = String(intervalVisitApplied);
                    persistState();
                    renderCalendar(false);
                });
            }
            
            if (storeSel && storeApplyBtn && storeAppliedText) {
                storeSel.value = String(intervalStoreApplied);
                storeAppliedText.textContent = String(intervalStoreApplied);
                storeSel.addEventListener('change', () => {
                    intervalStorePending = parseInt(storeSel.value, 10);
                });
                storeApplyBtn.addEventListener('click', () => {
                    intervalStoreApplied = intervalStorePending;
                    storeAppliedText.textContent = String(intervalStoreApplied);
                    persistState();
                    renderCalendar(false);
                });
            }
        })();

        // ========== シフト管理機能 ==========
        let currentMonth = new Date();
        let shifts = [];
        let patterns = [];
        let editingPatternId = null;

        // シフトデータの永続化
        function persistShiftData() {
            localStorage.setItem('rcs_shifts', JSON.stringify(shifts));
            localStorage.setItem('rcs_patterns', JSON.stringify(patterns));
        }

        function restoreShiftData() {
            try {
                shifts = JSON.parse(localStorage.getItem('rcs_shifts') || '[]');
                patterns = JSON.parse(localStorage.getItem('rcs_patterns') || '[]');
            } catch (e) {
                shifts = [];
                patterns = [];
            }
        }

        // 日付ユーティリティ
        function getMonthDays(year, month) {
            const firstDay = new Date(year, month, 1);
            const lastDay = new Date(year, month + 1, 0);
            const days = [];

            // 前月の日付を追加（週の開始を月曜日にするため）
            const firstDayOfWeek = firstDay.getDay();
            const offset = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
            
            for (let i = offset; i > 0; i--) {
                const date = new Date(year, month, 1 - i);
                days.push({ date, otherMonth: true });
            }

            // 当月の日付
            for (let i = 1; i <= lastDay.getDate(); i++) {
                const date = new Date(year, month, i);
                days.push({ date, otherMonth: false });
            }

            // 次月の日付を追加（7の倍数になるまで）
            const remaining = 7 - (days.length % 7);
            if (remaining < 7) {
                for (let i = 1; i <= remaining; i++) {
                    const date = new Date(year, month + 1, i);
                    days.push({ date, otherMonth: true });
                }
            }

            return days;
        }

        // シフトカレンダー描画
        function renderShiftCalendar() {
            const year = currentMonth.getFullYear();
            const month = currentMonth.getMonth();
            const days = getMonthDays(year, month);

            document.getElementById('monthInfo').textContent = 
                `${year}年${month + 1}月`;

            const grid = document.getElementById('shiftGrid');
            grid.innerHTML = '';

            // 曜日ヘッダー（固定のため祝日判定なし）
            const weekdays = ['月', '火', '水', '木', '金', '土', '日'];
            weekdays.forEach((day, index) => {
                const header = document.createElement('div');
                header.className = 'shift-day-header';
                // 0=月曜、5=土曜、6=日曜
                if (index === 5) {
                    header.classList.add('saturday'); // 土曜日
                } else if (index === 6) {
                    header.classList.add('sunday'); // 日曜日
                }
                header.textContent = day;
                grid.appendChild(header);
            });

            // 日付セル
            days.forEach(({ date, otherMonth }) => {
                const cell = document.createElement('div');
                cell.className = 'shift-day';
                if (otherMonth) cell.classList.add('other-month');

                const dateNum = document.createElement('div');
                dateNum.className = 'shift-date-num';
                dateNum.textContent = date.getDate();

                const dateStr = formatDate(date);
                const shift = shifts.find(s => s.date === dateStr);

                let statusDiv, timeDiv;
                
                if (!otherMonth) {
                    if (shift) {
                        cell.classList.add('has-shift');
                        if (shift.allDay) {
                            timeDiv = document.createElement('div');
                            timeDiv.className = 'shift-time';
                            timeDiv.textContent = '終日ブロック';
                        } else {
                            timeDiv = document.createElement('div');
                            timeDiv.className = 'shift-time';
                            let timeText = `${shift.startTime}〜${shift.endTime}`;
                            if (shift.breakStartTime && shift.breakEndTime) {
                                timeText += ` (休憩: ${shift.breakStartTime}〜${shift.breakEndTime})`;
                            }
                            timeDiv.textContent = timeText;
                        }
                        
                        statusDiv = document.createElement('div');
                        statusDiv.className = 'shift-status working';
                        statusDiv.textContent = shift.allDay ? 'ブロック' : '勤務';
                    } else {
                        const dayOfWeek = date.getDay();
                        if (dayOfWeek === 0 || dayOfWeek === 6) {
                            cell.classList.add('off-day');
                            statusDiv = document.createElement('div');
                            statusDiv.className = 'shift-status off';
                            statusDiv.textContent = '休み';
                        } else {
                            cell.classList.add('no-shift');
                            statusDiv = document.createElement('div');
                            statusDiv.className = 'shift-status warning';
                            statusDiv.textContent = '⚠️ 未登録';
                        }
                    }

                    cell.onclick = () => editShiftDay(dateStr, shift);
                }

                cell.appendChild(dateNum);
                if (timeDiv) cell.appendChild(timeDiv);
                if (statusDiv) cell.appendChild(statusDiv);
                
                grid.appendChild(cell);
            });
        }

        // 月変更
        function changeMonth(delta) {
            currentMonth.setMonth(currentMonth.getMonth() + delta);
            renderShiftCalendar();
            updateSummary();
            updateBlocksFromShifts();
        }

        // サマリー更新
        function updateSummary() {
            const year = currentMonth.getFullYear();
            const month = currentMonth.getMonth();
            const days = getMonthDays(year, month).filter(d => !d.otherMonth);

            let registered = 0;
            let unregistered = 0;
            let off = 0;

            days.forEach(({ date }) => {
                const dateStr = formatDate(date);
                const shift = shifts.find(s => s.date === dateStr);
                const dayOfWeek = date.getDay();

                if (shift) {
                    registered++;
                } else if (dayOfWeek === 0 || dayOfWeek === 6) {
                    off++;
                } else {
                    unregistered++;
                }
            });

            document.getElementById('summaryRegistered').textContent = `${registered}日`;
            document.getElementById('summaryUnregistered').textContent = `${unregistered}日`;
            document.getElementById('summaryOff').textContent = `${off}日`;
        }

        // シフトからブロックを更新
        function updateBlocksFromShifts() {
            // 既存のシフトブロックを削除
            blocks = blocks.filter(b => !b.fromShift);
            
            // シフトに基づいてブロックを追加
            shifts.forEach(shift => {
                if (shift.allDay) {
                    // 終日ブロック - 週の表示範囲全体をブロック
                    const dates = getWeekDates(currentWeek);
                    const range = getWeekTimeRange(dates);
                    const startTime = `${String(range.startHour).padStart(2, '0')}:00`;
                    const endTime = `${String(range.endHour).padStart(2, '0')}:00`;
                    
                    blocks.push({
                        id: Date.now() + Math.random(),
                        date: shift.date,
                        startTime: startTime,
                        endTime: endTime,
                        fromShift: true
                    });
                } else {
                    // シフト時間外をブロック（休憩時間も含む）
                    const dates = getWeekDates(currentWeek);
                    const range = getWeekTimeRange(dates);
                    const slots = getTimeSlots(dates);
                    
                    const startMinutes = timeToMinutes(shift.startTime);
                    const endTime = shift.endTime === '24:00' ? '24:00' : shift.endTime;
                    const endMinutes = endTime === '24:00' ? 24 * 60 : timeToMinutes(endTime);
                    
                    // 休憩時間の範囲を計算
                    let breakStartMinutes = null;
                    let breakEndMinutes = null;
                    if (shift.breakStartTime && shift.breakEndTime) {
                        breakStartMinutes = timeToMinutes(shift.breakStartTime);
                        const breakEndTime = shift.breakEndTime === '24:00' ? '24:00' : shift.breakEndTime;
                        breakEndMinutes = breakEndTime === '24:00' ? 24 * 60 : timeToMinutes(breakEndTime);
                    }
                    
                    slots.forEach((slot, index) => {
                        if (slot.endsWith(':00') && index === slots.length - 1) return;
                        
                        const slotMinutes = timeToMinutes(slot);
                        const nextSlot = slots[index + 1] || slots[slots.length - 1];
                        
                        // シフト時間外をブロック
                        if (slotMinutes < startMinutes || slotMinutes >= endMinutes) {
                            blocks.push({
                                id: Date.now() + Math.random(),
                                date: shift.date,
                                startTime: slot,
                                endTime: nextSlot,
                                fromShift: true
                            });
                        }
                        // 休憩時間をブロック
                        else if (breakStartMinutes !== null && breakEndMinutes !== null) {
                            if (slotMinutes >= breakStartMinutes && slotMinutes < breakEndMinutes) {
                                blocks.push({
                                    id: Date.now() + Math.random(),
                                    date: shift.date,
                                    startTime: slot,
                                    endTime: nextSlot,
                                    fromShift: true,
                                    isBreak: true
                                });
                            }
                        }
                    });
                }
            });
            
            persistState();
            renderCalendar(true);
            renderCalendar(false);
        }

        // 時間選択の初期化（24時間対応） - 全体的な初期化
        function initializeTimeSelects() {
            const selects = [
                'shiftStartTime', 'shiftEndTime',
                'bulkStartTime', 'bulkEndTime',
                'shiftBreakStartTime', 'shiftBreakEndTime'
            ];

            selects.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                select.innerHTML = '';
                // 0:00～23:59の範囲で生成
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += INTERVAL) {
                        const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                        const option = document.createElement('option');
                        option.value = time;
                        option.textContent = time;
                        select.appendChild(option);
                    }
                }
                // 24:00も追加
                const option24 = document.createElement('option');
                option24.value = '24:00';
                option24.textContent = '24:00';
                select.appendChild(option24);
            });

            // デフォルト値設定
            if (document.getElementById('shiftStartTime')) {
                document.getElementById('shiftStartTime').value = '10:00';
                document.getElementById('shiftEndTime').value = '19:00';
            }
            if (document.getElementById('bulkStartTime')) {
                document.getElementById('bulkStartTime').value = '10:00';
                document.getElementById('bulkEndTime').value = '19:00';
            }
        }

        // 個別シフト登録モーダル用の時間選択初期化
        function initializeShiftTimeSelects() {
            const selects = ['shiftStartTime', 'shiftEndTime', 'shiftBreakStartTime', 'shiftBreakEndTime'];
            
            selects.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                // 既に選択肢がある場合はスキップ（値を保持）
                if (select.children.length > 0) return;
                
                select.innerHTML = '';
                // 0:00～23:59の範囲で生成
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += INTERVAL) {
                        const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                        const option = document.createElement('option');
                        option.value = time;
                        option.textContent = time;
                        select.appendChild(option);
                    }
                }
                // 24:00も追加
                const option24 = document.createElement('option');
                option24.value = '24:00';
                option24.textContent = '24:00';
                select.appendChild(option24);
            });

            // デフォルト値設定
            const shiftStart = document.getElementById('shiftStartTime');
            const shiftEnd = document.getElementById('shiftEndTime');
            if (shiftStart && !shiftStart.value) {
                shiftStart.value = '10:00';
            }
            if (shiftEnd && !shiftEnd.value) {
                shiftEnd.value = '19:00';
            }
        }

        // 一括シフト登録モーダル用の時間選択初期化
        function initializeBulkTimeSelects() {
            const selects = ['bulkStartTime', 'bulkEndTime', 'bulkBreakStartTime', 'bulkBreakEndTime'];
            
            selects.forEach(id => {
                const select = document.getElementById(id);
                if (!select) return;
                
                // 既に選択肢がある場合はスキップ（値を保持）
                if (select.children.length > 0) return;
                
                select.innerHTML = '';
                // 0:00～23:59の範囲で生成
                for (let h = 0; h < 24; h++) {
                    for (let m = 0; m < 60; m += INTERVAL) {
                        const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                        const option = document.createElement('option');
                        option.value = time;
                        option.textContent = time;
                        select.appendChild(option);
                    }
                }
                // 24:00も追加
                const option24 = document.createElement('option');
                option24.value = '24:00';
                option24.textContent = '24:00';
                select.appendChild(option24);
            });

            // デフォルト値設定
            const bulkStart = document.getElementById('bulkStartTime');
            const bulkEnd = document.getElementById('bulkEndTime');
            const bulkBreakStart = document.getElementById('bulkBreakStartTime');
            const bulkBreakEnd = document.getElementById('bulkBreakEndTime');
            if (bulkStart && !bulkStart.value) {
                bulkStart.value = '10:00';
            }
            if (bulkEnd && !bulkEnd.value) {
                bulkEnd.value = '19:00';
            }
            if (bulkBreakStart && !bulkBreakStart.value) {
                bulkBreakStart.value = '12:00';
            }
            if (bulkBreakEnd && !bulkBreakEnd.value) {
                bulkBreakEnd.value = '13:00';
            }
        }

        // 一括シフト登録の休憩時間入力の切り替え
        function toggleBulkBreakInputs() {
            const hasBreak = document.getElementById('bulkHasBreak').checked;
            const breakTimeGroup = document.getElementById('bulkBreakTimeGroup');
            if (breakTimeGroup) {
                breakTimeGroup.style.display = hasBreak ? 'block' : 'none';
            }
        }

        // 休憩時間入力の切り替え
        function toggleBreakInputs() {
            const hasBreak = document.getElementById('shiftHasBreak').checked;
            const breakGroup = document.getElementById('breakTimeGroup');
            if (hasBreak) {
                breakGroup.style.display = 'block';
            } else {
                breakGroup.style.display = 'none';
            }
        }

        // 終日ブロックチェックボックスの切り替え
        function toggleShiftTimeInputs() {
            const allDay = document.getElementById('shiftAllDay').checked;
            const timeGroup = document.getElementById('shiftTimeGroup');
            const breakGroup = document.getElementById('shiftBreakGroup');
            if (allDay) {
                timeGroup.style.display = 'none';
                breakGroup.style.display = 'none';
            } else {
                timeGroup.style.display = 'block';
                breakGroup.style.display = 'block';
            }
        }

        // シフト日編集
        function editShiftDay(dateStr, shift) {
            if (shift) {
                // 編集
                document.getElementById('shiftDate').value = dateStr;
                document.getElementById('shiftAllDay').checked = shift.allDay || false;
                toggleShiftTimeInputs();
                if (!shift.allDay) {
                    document.getElementById('shiftStartTime').value = shift.startTime;
                    document.getElementById('shiftEndTime').value = shift.endTime;
                    if (shift.breakStartTime && shift.breakEndTime) {
                        document.getElementById('shiftHasBreak').checked = true;
                        document.getElementById('shiftBreakStartTime').value = shift.breakStartTime;
                        document.getElementById('shiftBreakEndTime').value = shift.breakEndTime;
                    } else {
                        document.getElementById('shiftHasBreak').checked = false;
                    }
                    toggleBreakInputs();
                }
                document.getElementById('shiftMemo').value = shift.memo || '';
                openShiftModal();
            } else {
                // 新規登録
                document.getElementById('shiftDate').value = dateStr;
                document.getElementById('shiftAllDay').checked = false;
                document.getElementById('shiftHasBreak').checked = false;
                toggleShiftTimeInputs();
                toggleBreakInputs();
                openShiftModal();
            }
        }

        // 個別シフト登録モーダル
        function openShiftModal() {
            const today = formatDate(new Date());
            if (!document.getElementById('shiftDate').value) {
                document.getElementById('shiftDate').value = today;
            }
            
            // 時間選択を初期化（モーダルが開かれるたびに確実に初期化）
            initializeShiftTimeSelects();
            
            document.getElementById('shiftModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeShiftModal() {
            document.getElementById('shiftModal').classList.remove('active');
            document.body.style.overflow = '';
            // リセット
            document.getElementById('shiftDate').value = '';
            document.getElementById('shiftAllDay').checked = false;
            document.getElementById('shiftHasBreak').checked = false;
            document.getElementById('shiftMemo').value = '';
            toggleShiftTimeInputs();
            toggleBreakInputs();
        }

        function saveShift() {
            const date = document.getElementById('shiftDate').value;
            const allDay = document.getElementById('shiftAllDay').checked;
            const startTime = document.getElementById('shiftStartTime').value;
            const endTime = document.getElementById('shiftEndTime').value;
            const hasBreak = document.getElementById('shiftHasBreak').checked;
            const breakStartTime = document.getElementById('shiftBreakStartTime').value;
            const breakEndTime = document.getElementById('shiftBreakEndTime').value;
            const memo = document.getElementById('shiftMemo').value;

            if (!date) {
                alert('日付を選択してください');
                return;
            }

            if (!allDay && (!startTime || !endTime)) {
                alert('勤務時間を選択してください');
                return;
            }

            // バリデーション
            if (!allDay) {
                const start = timeToMinutes(startTime);
                const end = timeToMinutes(endTime === '24:00' ? '24:00' : endTime);
                const endMinutes = end === '24:00' ? 24 * 60 : timeToMinutes(endTime);
                if (start >= endMinutes) {
                    alert('終了時刻は開始時刻より後に設定してください');
                    return;
                }

                // 休憩時間のバリデーション
                if (hasBreak && breakStartTime && breakEndTime) {
                    const breakStart = timeToMinutes(breakStartTime);
                    const breakEnd = timeToMinutes(breakEndTime === '24:00' ? '24:00' : breakEndTime);
                    const breakEndMinutes = breakEnd === '24:00' ? 24 * 60 : timeToMinutes(breakEndTime);
                    
                    if (breakStart >= breakEndMinutes) {
                        alert('休憩終了時刻は休憩開始時刻より後に設定してください');
                        return;
                    }
                    
                    if (breakStart < start || breakEndMinutes > endMinutes) {
                        alert('休憩時間は勤務時間の範囲内に設定してください');
                        return;
                    }
                }
            }

            // 既存シフトを削除
            shifts = shifts.filter(s => s.date !== date);

            // 新規追加
            const shiftData = {
                id: Date.now(),
                date,
                memo,
                patternId: null,
                patternName: null,
                allDay: allDay || false
            };
            
            if (!allDay) {
                shiftData.startTime = startTime;
                shiftData.endTime = endTime;
                if (hasBreak && breakStartTime && breakEndTime) {
                    shiftData.breakStartTime = breakStartTime;
                    shiftData.breakEndTime = breakEndTime;
                }
            }

            shifts.push(shiftData);

            persistShiftData();
            renderShiftCalendar();
            updateSummary();
            updateBlocksFromShifts();
            closeShiftModal();
            alert('シフトを登録しました');
        }

        // 一括シフト登録モーダル
        function openBulkShiftModal() {
            const today = new Date();
            const nextWeek = new Date(today);
            nextWeek.setDate(today.getDate() + 7);
            
            document.getElementById('bulkStartDate').value = formatDate(today);
            document.getElementById('bulkEndDate').value = formatDate(nextWeek);
            
            // 休憩時間チェックボックスをリセット
            const bulkHasBreak = document.getElementById('bulkHasBreak');
            if (bulkHasBreak) {
                bulkHasBreak.checked = false;
                toggleBulkBreakInputs();
            }
            
            // 時間選択を初期化（モーダルが開かれるたびに確実に初期化）
            initializeBulkTimeSelects();
            
            document.getElementById('bulkShiftModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeBulkShiftModal() {
            document.getElementById('bulkShiftModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function saveBulkShift() {
            const startDate = new Date(document.getElementById('bulkStartDate').value);
            const endDate = new Date(document.getElementById('bulkEndDate').value);
            const startTime = document.getElementById('bulkStartTime').value;
            const endTime = document.getElementById('bulkEndTime').value;
            const hasBreak = document.getElementById('bulkHasBreak').checked;
            const breakStartTime = hasBreak ? document.getElementById('bulkBreakStartTime').value : null;
            const breakEndTime = hasBreak ? document.getElementById('bulkBreakEndTime').value : null;

            // 選択された曜日
            const selectedDays = [];
            ['bulk-mon', 'bulk-tue', 'bulk-wed', 'bulk-thu', 'bulk-fri', 'bulk-sat', 'bulk-sun'].forEach(id => {
                const checkbox = document.getElementById(id);
                if (checkbox.checked) {
                    selectedDays.push(parseInt(checkbox.value));
                }
            });

            if (selectedDays.length === 0) {
                alert('対象曜日を選択してください');
                return;
            }

            // バリデーション
            {
                const start = timeToMinutes(startTime);
                const endTimeValue = endTime === '24:00' ? '24:00' : endTime;
                const end = endTimeValue === '24:00' ? 24 * 60 : timeToMinutes(endTime);
                if (start >= end) {
                    alert('終了時刻は開始時刻より後に設定してください');
                    return;
                }

                // 休憩時間のバリデーション
                if (hasBreak && breakStartTime && breakEndTime) {
                    const breakStart = timeToMinutes(breakStartTime);
                    const breakEnd = timeToMinutes(breakEndTime);
                    if (breakStart >= breakEnd) {
                        alert('休憩終了時刻は休憩開始時刻より後に設定してください');
                        return;
                    }
                    if (breakStart < start || breakEnd > end) {
                        alert('休憩時間は勤務時間の範囲内に設定してください');
                        return;
                    }
                }
            }

            let count = 0;
            let blockCount = 0;
            for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
                const dateStr = formatDate(date);
                const dayOfWeek = date.getDay();
                
                // 既存シフトを削除
                shifts = shifts.filter(s => s.date !== dateStr);
                
                // 曜日が選択されている場合
                if (selectedDays.includes(dayOfWeek)) {
                    // 選択された曜日はシフトを登録
                    const shiftData = {
                        id: Date.now() + count,
                        date: dateStr,
                        startTime,
                        endTime: endTime === '24:00' ? '24:00' : endTime,
                        memo: '',
                        patternId: null,
                        patternName: null,
                        allDay: false
                    };
                    
                    if (hasBreak && breakStartTime && breakEndTime) {
                        shiftData.breakStartTime = breakStartTime;
                        shiftData.breakEndTime = breakEndTime;
                    }
                    
                    shifts.push(shiftData);
                    count++;
                } else {
                    // 選択されていない曜日は終日ブロック
                    shifts.push({
                        id: Date.now() + count + blockCount + 1000000,
                        date: dateStr,
                        memo: '',
                        patternId: null,
                        patternName: null,
                        allDay: true
                    });
                    blockCount++;
                }
            }

            persistShiftData();
            renderShiftCalendar();
            updateSummary();
            updateBlocksFromShifts();
            closeBulkShiftModal();
            const message = count > 0 && blockCount > 0 
                ? `${count}件のシフトを登録し、${blockCount}件を終日ブロックしました`
                : count > 0 
                    ? `${count}件のシフトを登録しました`
                    : `${blockCount}件を終日ブロックしました`;
            alert(message);
        }

        // パターン管理モーダル
        function openPatternManageModal() {
            renderPatternList();
            document.getElementById('patternManageModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closePatternManageModal() {
            document.getElementById('patternManageModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function renderPatternList() {
            const list = document.getElementById('patternList');
            list.innerHTML = '';

            if (patterns.length === 0) {
                list.innerHTML = '<p style="text-align: center; color: #757575; padding: 20px;">パターンが登録されていません</p>';
                return;
            }

            patterns.forEach(pattern => {
                const card = document.createElement('div');
                card.className = 'pattern-card';

                const header = document.createElement('div');
                header.className = 'pattern-header';

                const name = document.createElement('div');
                name.className = 'pattern-name';
                name.textContent = pattern.name;

                const actions = document.createElement('div');
                actions.className = 'pattern-actions';

                const editBtn = document.createElement('button');
                editBtn.textContent = '編集';
                editBtn.onclick = () => editPattern(pattern.id);

                const deleteBtn = document.createElement('button');
                deleteBtn.textContent = '削除';
                deleteBtn.onclick = () => deletePattern(pattern.id);

                actions.appendChild(editBtn);
                actions.appendChild(deleteBtn);

                header.appendChild(name);
                header.appendChild(actions);

                const schedule = document.createElement('div');
                schedule.className = 'pattern-schedule';
                schedule.innerHTML = getPatternSummary(pattern);

                card.appendChild(header);
                card.appendChild(schedule);
                list.appendChild(card);
            });
        }

        function getPatternSummary(pattern) {
            const days = ['月', '火', '水', '木', '金', '土', '日'];
            const keys = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            
            let summary = '';
            keys.forEach((key, index) => {
                const day = pattern.schedule[key];
                if (day.enabled) {
                    let timeText = `${days[index]}: ${day.startTime}〜${day.endTime}`;
                    if (day.breakStartTime && day.breakEndTime) {
                        timeText += ` (休憩: ${day.breakStartTime}〜${day.breakEndTime})`;
                    }
                    summary += `${timeText}<br>`;
                } else {
                    summary += `${days[index]}: 休み<br>`;
                }
            });
            
            // 祝日の設定を表示
            if (pattern.schedule.holiday && pattern.schedule.holiday.enabled) {
                let holidayText = `祝日: ${pattern.schedule.holiday.startTime}〜${pattern.schedule.holiday.endTime}`;
                if (pattern.schedule.holiday.breakStartTime && pattern.schedule.holiday.breakEndTime) {
                    holidayText += ` (休憩: ${pattern.schedule.holiday.breakStartTime}〜${pattern.schedule.holiday.breakEndTime})`;
                }
                summary += `${holidayText}<br>`;
            }
            
            return summary;
        }

        // パターン編集モーダル
        function openPatternEditModal(patternId = null) {
            editingPatternId = patternId;
            
            if (patternId) {
                const pattern = patterns.find(p => p.id === patternId);
                document.getElementById('patternEditTitle').textContent = 'パターン編集';
                document.getElementById('patternName').value = pattern.name;
                document.getElementById('patternDescription').value = pattern.description || '';
            } else {
                document.getElementById('patternEditTitle').textContent = 'パターン作成';
                document.getElementById('patternName').value = '';
                document.getElementById('patternDescription').value = '';
            }

            renderPatternScheduleEditor(patternId);
            document.getElementById('patternEditModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closePatternEditModal() {
            document.getElementById('patternEditModal').classList.remove('active');
            document.body.style.overflow = '';
            editingPatternId = null;
        }

        function renderPatternScheduleEditor(patternId) {
            const editor = document.getElementById('patternScheduleEditor');
            editor.innerHTML = '';

            const days = ['月', '火', '水', '木', '金', '土', '日'];
            const keys = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];

            const pattern = patternId ? patterns.find(p => p.id === patternId) : null;

            keys.forEach((key, index) => {
                const row = document.createElement('div');
                row.className = 'schedule-row';

                const label = document.createElement('div');
                label.className = 'weekday-label';
                label.textContent = days[index];

                const controls = document.createElement('div');
                controls.className = 'time-controls';

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `pattern-${key}`;
                checkbox.checked = pattern ? pattern.schedule[key].enabled : true;

                const startSelect = createTimeSelect(`pattern-start-${key}`);
                const endSelect = createTimeSelect(`pattern-end-${key}`);

                if (pattern && pattern.schedule[key].enabled) {
                    startSelect.value = pattern.schedule[key].startTime;
                    endSelect.value = pattern.schedule[key].endTime;
                } else {
                    startSelect.value = '10:00';
                    endSelect.value = '19:00';
                }

                // 休憩時間の要素
                const breakCheckbox = document.createElement('input');
                breakCheckbox.type = 'checkbox';
                breakCheckbox.id = `pattern-break-${key}`;
                const hasBreak = pattern ? (pattern.schedule[key].breakStartTime && pattern.schedule[key].breakEndTime) : false;
                breakCheckbox.checked = hasBreak;

                const breakStartSelect = createTimeSelect(`pattern-break-start-${key}`);
                const breakEndSelect = createTimeSelect(`pattern-break-end-${key}`);

                if (pattern && hasBreak) {
                    breakStartSelect.value = pattern.schedule[key].breakStartTime;
                    breakEndSelect.value = pattern.schedule[key].breakEndTime;
                } else {
                    breakStartSelect.value = '12:00';
                    breakEndSelect.value = '13:00';
                }

                const breakTimeGroup = document.createElement('div');
                breakTimeGroup.style.cssText = 'display: none; margin-left: 28px; margin-top: 4px;';
                const breakTimeSelects = document.createElement('div');
                breakTimeSelects.style.cssText = 'display: flex; align-items: center; gap: 8px;';
                breakTimeSelects.appendChild(breakStartSelect);
                breakTimeSelects.appendChild(document.createTextNode(' 〜 '));
                breakTimeSelects.appendChild(breakEndSelect);
                breakTimeGroup.appendChild(breakTimeSelects);

                const updateControls = () => {
                    const enabled = checkbox.checked;
                    startSelect.disabled = !enabled;
                    endSelect.disabled = !enabled;
                    breakCheckbox.disabled = !enabled;
                    breakStartSelect.disabled = !enabled || !breakCheckbox.checked;
                    breakEndSelect.disabled = !enabled || !breakCheckbox.checked;
                    
                    if (!enabled) {
                        breakCheckbox.checked = false;
                        breakTimeGroup.style.display = 'none';
                    }
                };

                const updateBreakControls = () => {
                    const showBreak = checkbox.checked && breakCheckbox.checked;
                    breakTimeGroup.style.display = showBreak ? 'block' : 'none';
                    breakStartSelect.disabled = !checkbox.checked || !breakCheckbox.checked;
                    breakEndSelect.disabled = !checkbox.checked || !breakCheckbox.checked;
                };

                checkbox.addEventListener('change', updateControls);
                breakCheckbox.addEventListener('change', updateBreakControls);
                updateControls();
                updateBreakControls();

                // 勤務時間の行
                const workTimeRow = document.createElement('div');
                workTimeRow.style.cssText = 'display: flex; align-items: center; gap: 8px; width: 100%;';
                workTimeRow.appendChild(checkbox);
                workTimeRow.appendChild(startSelect);
                workTimeRow.appendChild(document.createTextNode(' 〜 '));
                workTimeRow.appendChild(endSelect);

                // 休憩時間の行
                const breakRow = document.createElement('div');
                breakRow.style.cssText = 'display: flex; flex-direction: column; width: 100%;';
                const breakLabel = document.createElement('label');
                breakLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
                breakLabel.appendChild(breakCheckbox);
                breakLabel.appendChild(document.createTextNode('休憩時間'));
                breakRow.appendChild(breakLabel);
                breakRow.appendChild(breakTimeGroup);

                controls.appendChild(workTimeRow);
                controls.appendChild(breakRow);

                row.appendChild(label);
                row.appendChild(controls);
                editor.appendChild(row);
            });
            
            // 祝日の設定を追加
            const holidayRow = document.createElement('div');
            holidayRow.className = 'schedule-row';
            
            const holidayLabel = document.createElement('div');
            holidayLabel.className = 'weekday-label';
            holidayLabel.textContent = '祝日';
            
            const holidayControls = document.createElement('div');
            holidayControls.className = 'time-controls';
            
            const holidayCheckbox = document.createElement('input');
            holidayCheckbox.type = 'checkbox';
            holidayCheckbox.id = 'pattern-holiday';
            holidayCheckbox.checked = pattern ? (pattern.holiday && pattern.holiday.enabled) : true;
            
            const holidayStartSelect = createTimeSelect('pattern-holiday-start');
            const holidayEndSelect = createTimeSelect('pattern-holiday-end');
            
            if (pattern && pattern.holiday && pattern.holiday.enabled) {
                holidayStartSelect.value = pattern.holiday.startTime;
                holidayEndSelect.value = pattern.holiday.endTime;
            } else {
                holidayStartSelect.value = '10:00';
                holidayEndSelect.value = '19:00';
            }
            
            // 休憩時間の要素
            const holidayBreakCheckbox = document.createElement('input');
            holidayBreakCheckbox.type = 'checkbox';
            holidayBreakCheckbox.id = 'pattern-holiday-break';
            const hasHolidayBreak = pattern ? (pattern.holiday && pattern.holiday.breakStartTime && pattern.holiday.breakEndTime) : false;
            holidayBreakCheckbox.checked = hasHolidayBreak;
            
            const holidayBreakStartSelect = createTimeSelect('pattern-holiday-break-start');
            const holidayBreakEndSelect = createTimeSelect('pattern-holiday-break-end');
            
            if (pattern && hasHolidayBreak) {
                holidayBreakStartSelect.value = pattern.holiday.breakStartTime;
                holidayBreakEndSelect.value = pattern.holiday.breakEndTime;
            } else {
                holidayBreakStartSelect.value = '12:00';
                holidayBreakEndSelect.value = '13:00';
            }
            
            const holidayBreakTimeGroup = document.createElement('div');
            holidayBreakTimeGroup.style.cssText = 'display: none; margin-left: 28px; margin-top: 4px;';
            const holidayBreakTimeSelects = document.createElement('div');
            holidayBreakTimeSelects.style.cssText = 'display: flex; align-items: center; gap: 8px;';
            holidayBreakTimeSelects.appendChild(holidayBreakStartSelect);
            holidayBreakTimeSelects.appendChild(document.createTextNode(' 〜 '));
            holidayBreakTimeSelects.appendChild(holidayBreakEndSelect);
            holidayBreakTimeGroup.appendChild(holidayBreakTimeSelects);
            
            const updateHolidayControls = () => {
                const enabled = holidayCheckbox.checked;
                holidayStartSelect.disabled = !enabled;
                holidayEndSelect.disabled = !enabled;
                holidayBreakCheckbox.disabled = !enabled;
                holidayBreakStartSelect.disabled = !enabled || !holidayBreakCheckbox.checked;
                holidayBreakEndSelect.disabled = !enabled || !holidayBreakCheckbox.checked;
                
                if (!enabled) {
                    holidayBreakCheckbox.checked = false;
                    holidayBreakTimeGroup.style.display = 'none';
                }
            };
            
            const updateHolidayBreakControls = () => {
                const showBreak = holidayCheckbox.checked && holidayBreakCheckbox.checked;
                holidayBreakTimeGroup.style.display = showBreak ? 'block' : 'none';
                holidayBreakStartSelect.disabled = !holidayCheckbox.checked || !holidayBreakCheckbox.checked;
                holidayBreakEndSelect.disabled = !holidayCheckbox.checked || !holidayBreakCheckbox.checked;
            };
            
            holidayCheckbox.addEventListener('change', updateHolidayControls);
            holidayBreakCheckbox.addEventListener('change', updateHolidayBreakControls);
            updateHolidayControls();
            updateHolidayBreakControls();
            
            // 勤務時間の行
            const holidayWorkTimeRow = document.createElement('div');
            holidayWorkTimeRow.style.cssText = 'display: flex; align-items: center; gap: 8px; width: 100%;';
            holidayWorkTimeRow.appendChild(holidayCheckbox);
            holidayWorkTimeRow.appendChild(holidayStartSelect);
            holidayWorkTimeRow.appendChild(document.createTextNode(' 〜 '));
            holidayWorkTimeRow.appendChild(holidayEndSelect);
            
            // 休憩時間の行
            const holidayBreakRow = document.createElement('div');
            holidayBreakRow.style.cssText = 'display: flex; flex-direction: column; width: 100%;';
            const holidayBreakLabel = document.createElement('label');
            holidayBreakLabel.style.cssText = 'display: flex; align-items: center; gap: 8px; cursor: pointer;';
            holidayBreakLabel.appendChild(holidayBreakCheckbox);
            holidayBreakLabel.appendChild(document.createTextNode('休憩時間'));
            holidayBreakRow.appendChild(holidayBreakLabel);
            holidayBreakRow.appendChild(holidayBreakTimeGroup);
            
            holidayControls.appendChild(holidayWorkTimeRow);
            holidayControls.appendChild(holidayBreakRow);
            
            holidayRow.appendChild(holidayLabel);
            holidayRow.appendChild(holidayControls);
            editor.appendChild(holidayRow);
        }

        function createTimeSelect(id) {
            const select = document.createElement('select');
            select.id = id;
            // 0:00～23:59の範囲で生成（24時間対応）
            for (let h = 0; h < 24; h++) {
                for (let m = 0; m < 60; m += INTERVAL) {
                    const time = `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
                    const option = document.createElement('option');
                    option.value = time;
                    option.textContent = time;
                    select.appendChild(option);
                }
            }
            // 24:00も追加
            const option24 = document.createElement('option');
            option24.value = '24:00';
            option24.textContent = '24:00';
            select.appendChild(option24);
            return select;
        }

        function savePattern() {
            const name = document.getElementById('patternName').value.trim();
            const description = document.getElementById('patternDescription').value.trim();

            if (!name) {
                alert('パターン名を入力してください');
                return;
            }

            const keys = ['monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday', 'sunday'];
            const schedule = {};

            keys.forEach(key => {
                const checkbox = document.getElementById(`pattern-${key}`);
                const enabled = checkbox.checked;
                
                if (enabled) {
                    const startTime = document.getElementById(`pattern-start-${key}`).value;
                    const endTime = document.getElementById(`pattern-end-${key}`).value;
                    const breakCheckbox = document.getElementById(`pattern-break-${key}`);
                    const hasBreak = breakCheckbox && breakCheckbox.checked;
                    
                    if (hasBreak) {
                        const breakStartTime = document.getElementById(`pattern-break-start-${key}`).value;
                        const breakEndTime = document.getElementById(`pattern-break-end-${key}`).value;
                        schedule[key] = { 
                            enabled: true, 
                            startTime, 
                            endTime,
                            breakStartTime,
                            breakEndTime
                        };
                    } else {
                        schedule[key] = { enabled: true, startTime, endTime };
                    }
                } else {
                    schedule[key] = { enabled: false };
                }
            });
            
            // 祝日の設定を保存
            const holidayCheckbox = document.getElementById('pattern-holiday');
            const holidayEnabled = holidayCheckbox && holidayCheckbox.checked;
            
            if (holidayEnabled) {
                const holidayStartTime = document.getElementById('pattern-holiday-start').value;
                const holidayEndTime = document.getElementById('pattern-holiday-end').value;
                const holidayBreakCheckbox = document.getElementById('pattern-holiday-break');
                const hasHolidayBreak = holidayBreakCheckbox && holidayBreakCheckbox.checked;
                
                if (hasHolidayBreak) {
                    const holidayBreakStartTime = document.getElementById('pattern-holiday-break-start').value;
                    const holidayBreakEndTime = document.getElementById('pattern-holiday-break-end').value;
                    schedule.holiday = {
                        enabled: true,
                        startTime: holidayStartTime,
                        endTime: holidayEndTime,
                        breakStartTime: holidayBreakStartTime,
                        breakEndTime: holidayBreakEndTime
                    };
                } else {
                    schedule.holiday = {
                        enabled: true,
                        startTime: holidayStartTime,
                        endTime: holidayEndTime
                    };
                }
            } else {
                schedule.holiday = { enabled: false };
            }

            if (editingPatternId) {
                // 編集
                const pattern = patterns.find(p => p.id === editingPatternId);
                pattern.name = name;
                pattern.description = description;
                pattern.schedule = schedule;
            } else {
                // 新規
                patterns.push({
                    id: Date.now(),
                    name,
                    description,
                    schedule
                });
            }

            persistShiftData();
            renderPatternList();
            closePatternEditModal();
            alert('パターンを保存しました');
        }

        function editPattern(patternId) {
            closePatternManageModal();
            openPatternEditModal(patternId);
        }

        function deletePattern(patternId) {
            if (!confirm('このパターンを削除しますか?')) return;
            patterns = patterns.filter(p => p.id !== patternId);
            persistShiftData();
            renderPatternList();
        }

        // パターン適用モーダル
        function openPatternApplyModal() {
            const select = document.getElementById('patternSelect');
            select.innerHTML = '<option value="">選択してください</option>';
            
            patterns.forEach(pattern => {
                const option = document.createElement('option');
                option.value = pattern.id;
                option.textContent = pattern.name;
                select.appendChild(option);
            });

            const today = new Date();
            const nextMonth = new Date(today);
            nextMonth.setMonth(today.getMonth() + 1);
            
            document.getElementById('applyStartDate').value = formatDate(today);
            document.getElementById('applyEndDate').value = formatDate(nextMonth);
            document.getElementById('overwriteShifts').checked = false;

            document.getElementById('patternApplyModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closePatternApplyModal() {
            document.getElementById('patternApplyModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        function applyPattern() {
            const patternId = parseInt(document.getElementById('patternSelect').value);
            const startDate = new Date(document.getElementById('applyStartDate').value);
            const endDate = new Date(document.getElementById('applyEndDate').value);
            const overwrite = document.getElementById('overwriteShifts').checked;

            if (!patternId) {
                alert('パターンを選択してください');
                return;
            }

            const pattern = patterns.find(p => p.id === patternId);
            if (!pattern) return;

            const keys = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
            let count = 0;

            for (let date = new Date(startDate); date <= endDate; date.setDate(date.getDate() + 1)) {
                const dateStr = formatDate(date);
                const dayOfWeek = date.getDay();
                const dayKey = keys[dayOfWeek];
                const daySetting = pattern.schedule[dayKey];
                const isHoliday = isJapaneseHoliday(date);
                const holidaySetting = pattern.schedule.holiday;

                // 既存シフトチェック
                const existingShift = shifts.find(s => s.date === dateStr);
                if (existingShift && !overwrite) continue;

                // 祝日設定が有効で祝日の場合は祝日設定を使用、それ以外は曜日設定を使用
                const useHoliday = holidaySetting && holidaySetting.enabled && isHoliday;
                const targetSetting = useHoliday ? holidaySetting : daySetting;

                if (targetSetting && targetSetting.enabled) {
                    // 既存シフトを削除
                    shifts = shifts.filter(s => s.date !== dateStr);

                    // 新規追加
                    const shiftData = {
                        id: Date.now() + count,
                        date: dateStr,
                        startTime: targetSetting.startTime,
                        endTime: targetSetting.endTime,
                        memo: '',
                        patternId: pattern.id,
                        patternName: pattern.name,
                        allDay: false
                    };

                    // 休憩時間があれば追加
                    if (targetSetting.breakStartTime && targetSetting.breakEndTime) {
                        shiftData.breakStartTime = targetSetting.breakStartTime;
                        shiftData.breakEndTime = targetSetting.breakEndTime;
                    }

                    shifts.push(shiftData);
                    count++;
                } else if (overwrite && existingShift) {
                    // 休日設定の場合は既存シフトを削除
                    shifts = shifts.filter(s => s.date !== dateStr);
                }
            }

            persistShiftData();
            renderShiftCalendar();
            updateSummary();
            updateBlocksFromShifts();
            closePatternApplyModal();
            alert(`${count}件のシフトを登録しました`);
        }

        // 初期化
        restoreState();
        restoreShiftData();
        (function syncIntervalUI(){
            const visitSel = document.getElementById('intervalVisitSelect');
            const visitAppliedText = document.getElementById('appliedIntervalVisitText');
            if (visitSel) visitSel.value = String(intervalVisitApplied);
            if (visitAppliedText) visitAppliedText.textContent = String(intervalVisitApplied);
            
            const storeSel = document.getElementById('intervalStoreSelect');
            const storeAppliedText = document.getElementById('appliedIntervalStoreText');
            if (storeSel) storeSel.value = String(intervalStoreApplied);
            if (storeAppliedText) storeAppliedText.textContent = String(intervalStoreApplied);
        })();
        initializeTimeSelects();
        renderShiftCalendar();
        updateSummary();
        updateBlocksFromShifts();
        renderCalendar(true);
        renderCalendar(false);
        updatePendingBadge();
    </script>

    <!-- 個別シフト登録モーダル -->
    <div class="modal" id="shiftModal">
        <div class="modal-content">
            <div class="modal-header">シフト登録</div>
            <div class="modal-body">
                <div class="form-group">
                    <label>日付 *</label>
                    <input type="date" id="shiftDate" required>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="shiftAllDay" onchange="toggleShiftTimeInputs()">
                        終日ブロック
                    </label>
                </div>
                <div class="form-group" id="shiftTimeGroup">
                    <label>勤務時間 *</label>
                    <div class="time-range">
                        <select id="shiftStartTime"></select>
                        <span>〜</span>
                        <select id="shiftEndTime"></select>
                    </div>
                </div>
                <div class="form-group" id="shiftBreakGroup">
                    <label>
                        <input type="checkbox" id="shiftHasBreak" onchange="toggleBreakInputs()">
                        休憩時間を設定する
                    </label>
                    <div id="breakTimeGroup" style="display: none; margin-top: 12px;">
                        <div class="time-range">
                            <select id="shiftBreakStartTime"></select>
                            <span>〜</span>
                            <select id="shiftBreakEndTime"></select>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>メモ</label>
                    <textarea id="shiftMemo" rows="3" placeholder="備考があれば入力してください"></textarea>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeShiftModal()">キャンセル</button>
                <button class="btn-primary" onclick="saveShift()">登録</button>
            </div>
        </div>
    </div>

    <!-- 一括シフト登録モーダル -->
    <div class="modal" id="bulkShiftModal">
        <div class="modal-content">
            <div class="modal-header">一括シフト登録</div>
            <div class="modal-body">
                <div class="form-group">
                    <label>期間 *</label>
                    <div class="time-range">
                        <input type="date" id="bulkStartDate" required>
                        <span>〜</span>
                        <input type="date" id="bulkEndDate" required>
                    </div>
                </div>
                <div class="form-group">
                    <label>対象曜日 *</label>
                    <div class="weekday-selector">
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-mon" value="1">
                            <label for="bulk-mon">月</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-tue" value="2">
                            <label for="bulk-tue">火</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-wed" value="3">
                            <label for="bulk-wed">水</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-thu" value="4">
                            <label for="bulk-thu">木</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-fri" value="5">
                            <label for="bulk-fri">金</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-sat" value="6">
                            <label for="bulk-sat">土</label>
                        </div>
                        <div class="weekday-checkbox">
                            <input type="checkbox" id="bulk-sun" value="0">
                            <label for="bulk-sun">日</label>
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <label>勤務時間 *</label>
                    <div class="time-range">
                        <select id="bulkStartTime"></select>
                        <span>〜</span>
                        <select id="bulkEndTime"></select>
                    </div>
                </div>
                <div class="form-group" id="bulkBreakGroup">
                    <label>
                        <input type="checkbox" id="bulkHasBreak" onchange="toggleBulkBreakInputs()">
                        休憩時間を設定する
                    </label>
                    <div id="bulkBreakTimeGroup" style="display: none; margin-top: 12px;">
                        <div class="time-range">
                            <select id="bulkBreakStartTime"></select>
                            <span>〜</span>
                            <select id="bulkBreakEndTime"></select>
                        </div>
                    </div>
                </div>
                <p style="color: #f57c00; font-size: 13px; margin-top: 12px;">
                    ⚠️ 既存のシフトがある日は上書きされます
                </p>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closeBulkShiftModal()">キャンセル</button>
                <button class="btn-primary" onclick="saveBulkShift()">一括登録</button>
            </div>
        </div>
    </div>

    <!-- パターン管理モーダル -->
    <div class="modal" id="patternManageModal">
        <div class="modal-content">
            <div class="modal-header">稼働パターン管理</div>
            <div class="modal-body">
                <button class="btn-primary" onclick="openPatternEditModal()" style="width: 100%; margin-bottom: 20px; padding: 12px 24px;">
                    + 新規パターン作成
                </button>
                <div class="pattern-list" id="patternList"></div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closePatternManageModal()">閉じる</button>
            </div>
        </div>
    </div>

    <!-- パターン編集モーダル -->
    <div class="modal" id="patternEditModal">
        <div class="modal-content">
            <div class="modal-header" id="patternEditTitle">稼働パターン作成</div>
            <div class="modal-body">
                <div class="form-group">
                    <label>パターン名 *</label>
                    <input type="text" id="patternName" placeholder="例: 通常営業">
                </div>
                <div class="form-group">
                    <label>説明</label>
                    <textarea id="patternDescription" rows="2" placeholder="パターンの説明を入力"></textarea>
                </div>
                <div class="form-group">
                    <label>曜日別設定</label>
                    <div class="pattern-schedule-editor" id="patternScheduleEditor"></div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closePatternEditModal()">キャンセル</button>
                <button class="btn-primary" onclick="savePattern()">保存</button>
            </div>
        </div>
    </div>

    <!-- パターン適用モーダル -->
    <div class="modal" id="patternApplyModal">
        <div class="modal-content">
            <div class="modal-header">パターン適用</div>
            <div class="modal-body">
                <div class="form-group">
                    <label>パターン *</label>
                    <select id="patternSelect"></select>
                </div>
                <div class="form-group">
                    <label>適用期間 *</label>
                    <div class="time-range">
                        <input type="date" id="applyStartDate" required>
                        <span>〜</span>
                        <input type="date" id="applyEndDate" required>
                    </div>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="overwriteShifts">
                        既存シフトを上書きする
                    </label>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn-secondary" onclick="closePatternApplyModal()">キャンセル</button>
                <button class="btn-primary" onclick="applyPattern()">適用</button>
            </div>
        </div>
    </div>
</body>
</html>
